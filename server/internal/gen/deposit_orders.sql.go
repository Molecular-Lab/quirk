// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: deposit_orders.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeDepositOrder = `-- name: CompleteDepositOrder :one
UPDATE deposit_orders
SET status = 'completed',
    crypto_amount = $2,
    transaction_hash = $3,
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at
`

type CompleteDepositOrderParams struct {
	ID              uuid.UUID      `db:"id"`
	CryptoAmount    pgtype.Numeric `db:"crypto_amount"`
	TransactionHash *string        `db:"transaction_hash"`
}

// Mark deposit order as completed with crypto amount and tx hash
func (q *Queries) CompleteDepositOrder(ctx context.Context, arg CompleteDepositOrderParams) (DepositOrder, error) {
	row := q.db.QueryRow(ctx, completeDepositOrder, arg.ID, arg.CryptoAmount, arg.TransactionHash)
	var i DepositOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.FiatAmount,
		&i.FiatCurrency,
		&i.CryptoAmount,
		&i.Chain,
		&i.TokenSymbol,
		&i.TokenAddress,
		&i.OnRampProvider,
		&i.PaymentUrl,
		&i.QrCode,
		&i.Status,
		&i.TransactionHash,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createDepositOrder = `-- name: CreateDepositOrder :one
INSERT INTO deposit_orders (
  order_id,
  client_id,
  user_id,
  fiat_amount,
  fiat_currency,
  crypto_amount,
  chain,
  token_symbol,
  token_address,
  on_ramp_provider,
  payment_url,
  qr_code,
  status,
  transaction_hash,
  gateway_fee,
  proxify_fee,
  network_fee,
  total_fees,
  expires_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
  $11, $12, $13, $14, $15, $16, $17, $18, $19
)
RETURNING id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at
`

type CreateDepositOrderParams struct {
	OrderID         string         `db:"order_id"`
	ClientID        uuid.UUID      `db:"client_id"`
	UserID          uuid.UUID      `db:"user_id"`
	FiatAmount      pgtype.Numeric `db:"fiat_amount"`
	FiatCurrency    string         `db:"fiat_currency"`
	CryptoAmount    pgtype.Numeric `db:"crypto_amount"`
	Chain           string         `db:"chain"`
	TokenSymbol     string         `db:"token_symbol"`
	TokenAddress    *string        `db:"token_address"`
	OnRampProvider  string         `db:"on_ramp_provider"`
	PaymentUrl      *string        `db:"payment_url"`
	QrCode          *string        `db:"qr_code"`
	Status          string         `db:"status"`
	TransactionHash *string        `db:"transaction_hash"`
	GatewayFee      pgtype.Numeric `db:"gateway_fee"`
	ProxifyFee      pgtype.Numeric `db:"proxify_fee"`
	NetworkFee      pgtype.Numeric `db:"network_fee"`
	TotalFees       pgtype.Numeric `db:"total_fees"`
	ExpiresAt       *time.Time     `db:"expires_at"`
}

func (q *Queries) CreateDepositOrder(ctx context.Context, arg CreateDepositOrderParams) (DepositOrder, error) {
	row := q.db.QueryRow(ctx, createDepositOrder,
		arg.OrderID,
		arg.ClientID,
		arg.UserID,
		arg.FiatAmount,
		arg.FiatCurrency,
		arg.CryptoAmount,
		arg.Chain,
		arg.TokenSymbol,
		arg.TokenAddress,
		arg.OnRampProvider,
		arg.PaymentUrl,
		arg.QrCode,
		arg.Status,
		arg.TransactionHash,
		arg.GatewayFee,
		arg.ProxifyFee,
		arg.NetworkFee,
		arg.TotalFees,
		arg.ExpiresAt,
	)
	var i DepositOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.FiatAmount,
		&i.FiatCurrency,
		&i.CryptoAmount,
		&i.Chain,
		&i.TokenSymbol,
		&i.TokenAddress,
		&i.OnRampProvider,
		&i.PaymentUrl,
		&i.QrCode,
		&i.Status,
		&i.TransactionHash,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const failDepositOrder = `-- name: FailDepositOrder :exec
UPDATE deposit_orders
SET status = 'failed',
    updated_at = NOW()
WHERE id = $1
`

// Mark deposit order as failed
func (q *Queries) FailDepositOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, failDepositOrder, id)
	return err
}

const getDepositOrder = `-- name: GetDepositOrder :one

SELECT id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at FROM deposit_orders
WHERE id = $1 LIMIT 1
`

// ============================================
// DEPOSIT ORDERS QUERIES (For Operations Dashboard Demo)
// ============================================
func (q *Queries) GetDepositOrder(ctx context.Context, id uuid.UUID) (DepositOrder, error) {
	row := q.db.QueryRow(ctx, getDepositOrder, id)
	var i DepositOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.FiatAmount,
		&i.FiatCurrency,
		&i.CryptoAmount,
		&i.Chain,
		&i.TokenSymbol,
		&i.TokenAddress,
		&i.OnRampProvider,
		&i.PaymentUrl,
		&i.QrCode,
		&i.Status,
		&i.TransactionHash,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getDepositOrderByOrderId = `-- name: GetDepositOrderByOrderId :one
SELECT id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at FROM deposit_orders
WHERE order_id = $1 LIMIT 1
`

func (q *Queries) GetDepositOrderByOrderId(ctx context.Context, orderID string) (DepositOrder, error) {
	row := q.db.QueryRow(ctx, getDepositOrderByOrderId, orderID)
	var i DepositOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.FiatAmount,
		&i.FiatCurrency,
		&i.CryptoAmount,
		&i.Chain,
		&i.TokenSymbol,
		&i.TokenAddress,
		&i.OnRampProvider,
		&i.PaymentUrl,
		&i.QrCode,
		&i.Status,
		&i.TransactionHash,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getDepositOrderStats = `-- name: GetDepositOrderStats :one
SELECT
  COUNT(*) AS total_orders,
  COUNT(*) FILTER (WHERE status = 'pending') AS pending_orders,
  COUNT(*) FILTER (WHERE status = 'completed') AS completed_orders,
  COUNT(*) FILTER (WHERE status = 'failed') AS failed_orders,
  COALESCE(SUM(fiat_amount) FILTER (WHERE status = 'pending'), 0) AS total_pending_amount,
  COALESCE(SUM(crypto_amount) FILTER (WHERE status = 'completed'), 0) AS total_completed_amount
FROM deposit_orders
WHERE created_at >= $1
  AND created_at <= $2
`

type GetDepositOrderStatsParams struct {
	StartDate *time.Time `db:"start_date"`
	EndDate   *time.Time `db:"end_date"`
}

type GetDepositOrderStatsRow struct {
	TotalOrders          int64       `db:"total_orders"`
	PendingOrders        int64       `db:"pending_orders"`
	CompletedOrders      int64       `db:"completed_orders"`
	FailedOrders         int64       `db:"failed_orders"`
	TotalPendingAmount   interface{} `db:"total_pending_amount"`
	TotalCompletedAmount interface{} `db:"total_completed_amount"`
}

// Get deposit order statistics for operations dashboard
func (q *Queries) GetDepositOrderStats(ctx context.Context, arg GetDepositOrderStatsParams) (GetDepositOrderStatsRow, error) {
	row := q.db.QueryRow(ctx, getDepositOrderStats, arg.StartDate, arg.EndDate)
	var i GetDepositOrderStatsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.PendingOrders,
		&i.CompletedOrders,
		&i.FailedOrders,
		&i.TotalPendingAmount,
		&i.TotalCompletedAmount,
	)
	return i, err
}

const listDepositOrdersByClient = `-- name: ListDepositOrdersByClient :many
SELECT id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at FROM deposit_orders
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDepositOrdersByClientParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListDepositOrdersByClient(ctx context.Context, arg ListDepositOrdersByClientParams) ([]DepositOrder, error) {
	rows, err := q.db.Query(ctx, listDepositOrdersByClient, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositOrder
	for rows.Next() {
		var i DepositOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.FiatAmount,
			&i.FiatCurrency,
			&i.CryptoAmount,
			&i.Chain,
			&i.TokenSymbol,
			&i.TokenAddress,
			&i.OnRampProvider,
			&i.PaymentUrl,
			&i.QrCode,
			&i.Status,
			&i.TransactionHash,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDepositOrdersByUser = `-- name: ListDepositOrdersByUser :many
SELECT id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at FROM deposit_orders
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDepositOrdersByUserParams struct {
	UserID uuid.UUID `db:"user_id"`
	Limit  int32     `db:"limit"`
	Offset int32     `db:"offset"`
}

func (q *Queries) ListDepositOrdersByUser(ctx context.Context, arg ListDepositOrdersByUserParams) ([]DepositOrder, error) {
	rows, err := q.db.Query(ctx, listDepositOrdersByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositOrder
	for rows.Next() {
		var i DepositOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.FiatAmount,
			&i.FiatCurrency,
			&i.CryptoAmount,
			&i.Chain,
			&i.TokenSymbol,
			&i.TokenAddress,
			&i.OnRampProvider,
			&i.PaymentUrl,
			&i.QrCode,
			&i.Status,
			&i.TransactionHash,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDepositOrders = `-- name: ListPendingDepositOrders :many
SELECT id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at FROM deposit_orders
WHERE status = 'pending'
ORDER BY created_at ASC
`

// Get all pending deposit orders across all clients (for operations dashboard)
func (q *Queries) ListPendingDepositOrders(ctx context.Context) ([]DepositOrder, error) {
	rows, err := q.db.Query(ctx, listPendingDepositOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositOrder
	for rows.Next() {
		var i DepositOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.FiatAmount,
			&i.FiatCurrency,
			&i.CryptoAmount,
			&i.Chain,
			&i.TokenSymbol,
			&i.TokenAddress,
			&i.OnRampProvider,
			&i.PaymentUrl,
			&i.QrCode,
			&i.Status,
			&i.TransactionHash,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDepositOrdersByClient = `-- name: ListPendingDepositOrdersByClient :many
SELECT id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at FROM deposit_orders
WHERE client_id = $1
  AND status = 'pending'
ORDER BY created_at ASC
`

// Get pending deposit orders for a specific client
func (q *Queries) ListPendingDepositOrdersByClient(ctx context.Context, clientID uuid.UUID) ([]DepositOrder, error) {
	rows, err := q.db.Query(ctx, listPendingDepositOrdersByClient, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositOrder
	for rows.Next() {
		var i DepositOrder
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.FiatAmount,
			&i.FiatCurrency,
			&i.CryptoAmount,
			&i.Chain,
			&i.TokenSymbol,
			&i.TokenAddress,
			&i.OnRampProvider,
			&i.PaymentUrl,
			&i.QrCode,
			&i.Status,
			&i.TransactionHash,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDepositOrderStatus = `-- name: UpdateDepositOrderStatus :one
UPDATE deposit_orders
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, order_id, client_id, user_id, fiat_amount, fiat_currency, crypto_amount, chain, token_symbol, token_address, on_ramp_provider, payment_url, qr_code, status, transaction_hash, gateway_fee, proxify_fee, network_fee, total_fees, created_at, updated_at, completed_at, expires_at
`

type UpdateDepositOrderStatusParams struct {
	ID     uuid.UUID `db:"id"`
	Status string    `db:"status"`
}

func (q *Queries) UpdateDepositOrderStatus(ctx context.Context, arg UpdateDepositOrderStatusParams) (DepositOrder, error) {
	row := q.db.QueryRow(ctx, updateDepositOrderStatus, arg.ID, arg.Status)
	var i DepositOrder
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.FiatAmount,
		&i.FiatCurrency,
		&i.CryptoAmount,
		&i.Chain,
		&i.TokenSymbol,
		&i.TokenAddress,
		&i.OnRampProvider,
		&i.PaymentUrl,
		&i.QrCode,
		&i.Status,
		&i.TransactionHash,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}
