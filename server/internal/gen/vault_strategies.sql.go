// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vault_strategies.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createVaultStrategy = `-- name: CreateVaultStrategy :one

INSERT INTO vault_strategies (
  client_vault_id,
  category,
  target_percent
) VALUES (
  $1, $2, $3
)
RETURNING id, client_vault_id, category, target_percent, created_at, updated_at
`

type CreateVaultStrategyParams struct {
	ClientVaultID uuid.UUID      `db:"client_vault_id"`
	Category      string         `db:"category"`
	TargetPercent pgtype.Numeric `db:"target_percent"`
}

// ============================================
// VAULT STRATEGIES QUERIES
// ============================================
func (q *Queries) CreateVaultStrategy(ctx context.Context, arg CreateVaultStrategyParams) (VaultStrategy, error) {
	row := q.db.QueryRow(ctx, createVaultStrategy, arg.ClientVaultID, arg.Category, arg.TargetPercent)
	var i VaultStrategy
	err := row.Scan(
		&i.ID,
		&i.ClientVaultID,
		&i.Category,
		&i.TargetPercent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllVaultStrategies = `-- name: DeleteAllVaultStrategies :exec
DELETE FROM vault_strategies
WHERE client_vault_id = $1
`

func (q *Queries) DeleteAllVaultStrategies(ctx context.Context, clientVaultID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllVaultStrategies, clientVaultID)
	return err
}

const getVaultStrategies = `-- name: GetVaultStrategies :many
SELECT id, client_vault_id, category, target_percent, created_at, updated_at FROM vault_strategies
WHERE client_vault_id = $1
ORDER BY category
`

func (q *Queries) GetVaultStrategies(ctx context.Context, clientVaultID uuid.UUID) ([]VaultStrategy, error) {
	rows, err := q.db.Query(ctx, getVaultStrategies, clientVaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VaultStrategy
	for rows.Next() {
		var i VaultStrategy
		if err := rows.Scan(
			&i.ID,
			&i.ClientVaultID,
			&i.Category,
			&i.TargetPercent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVaultStrategy = `-- name: UpsertVaultStrategy :one
INSERT INTO vault_strategies (
  client_vault_id,
  category,
  target_percent
) VALUES (
  $1, $2, $3
)
ON CONFLICT (client_vault_id, category)
DO UPDATE SET
  target_percent = EXCLUDED.target_percent,
  updated_at = now()
RETURNING id, client_vault_id, category, target_percent, created_at, updated_at
`

type UpsertVaultStrategyParams struct {
	ClientVaultID uuid.UUID      `db:"client_vault_id"`
	Category      string         `db:"category"`
	TargetPercent pgtype.Numeric `db:"target_percent"`
}

func (q *Queries) UpsertVaultStrategy(ctx context.Context, arg UpsertVaultStrategyParams) (VaultStrategy, error) {
	row := q.db.QueryRow(ctx, upsertVaultStrategy, arg.ClientVaultID, arg.Category, arg.TargetPercent)
	var i VaultStrategy
	err := row.Scan(
		&i.ID,
		&i.ClientVaultID,
		&i.Category,
		&i.TargetPercent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
