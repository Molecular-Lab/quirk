// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: withdrawal.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeWithdrawal = `-- name: CompleteWithdrawal :one
UPDATE withdrawal_transactions
SET status = 'completed',
    actual_amount = COALESCE($2, actual_amount),
    completed_at = now()
WHERE id = $1
RETURNING id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code
`

type CompleteWithdrawalParams struct {
	ID           uuid.UUID      `db:"id"`
	ActualAmount pgtype.Numeric `db:"actual_amount"`
}

// Mark withdrawal as completed
func (q *Queries) CompleteWithdrawal(ctx context.Context, arg CompleteWithdrawalParams) (WithdrawalTransaction, error) {
	row := q.db.QueryRow(ctx, completeWithdrawal, arg.ID, arg.ActualAmount)
	var i WithdrawalTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.RequestedAmount,
		&i.ActualAmount,
		&i.Currency,
		&i.WithdrawalFee,
		&i.NetworkFee,
		&i.GatewayOrderID,
		&i.DestinationType,
		&i.DestinationDetails,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const completeWithdrawalQueue = `-- name: CompleteWithdrawalQueue :exec
UPDATE withdrawal_queue
SET status = 'completed',
    completed_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) CompleteWithdrawalQueue(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, completeWithdrawalQueue, id)
	return err
}

const createWithdrawal = `-- name: CreateWithdrawal :one
INSERT INTO withdrawal_transactions (
  order_id,
  client_id,
  user_id,
  requested_amount,
  currency,
  destination_type,
  destination_details,
  status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code
`

type CreateWithdrawalParams struct {
	OrderID            string         `db:"order_id"`
	ClientID           uuid.UUID      `db:"client_id"`
	UserID             string         `db:"user_id"`
	RequestedAmount    pgtype.Numeric `db:"requested_amount"`
	Currency           string         `db:"currency"`
	DestinationType    string         `db:"destination_type"`
	DestinationDetails []byte         `db:"destination_details"`
	Status             string         `db:"status"`
}

func (q *Queries) CreateWithdrawal(ctx context.Context, arg CreateWithdrawalParams) (WithdrawalTransaction, error) {
	row := q.db.QueryRow(ctx, createWithdrawal,
		arg.OrderID,
		arg.ClientID,
		arg.UserID,
		arg.RequestedAmount,
		arg.Currency,
		arg.DestinationType,
		arg.DestinationDetails,
		arg.Status,
	)
	var i WithdrawalTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.RequestedAmount,
		&i.ActualAmount,
		&i.Currency,
		&i.WithdrawalFee,
		&i.NetworkFee,
		&i.GatewayOrderID,
		&i.DestinationType,
		&i.DestinationDetails,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const createWithdrawalQueueItem = `-- name: CreateWithdrawalQueueItem :one
INSERT INTO withdrawal_queue (
  client_id,
  withdrawal_transaction_id,
  end_user_vault_id,
  shares_to_burn,
  estimated_amount,
  protocols_to_unstake,
  priority,
  status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, client_id, withdrawal_transaction_id, end_user_vault_id, shares_to_burn, estimated_amount, actual_amount, protocols_to_unstake, priority, status, queued_at, unstaking_started_at, ready_at, completed_at, error_message, created_at, updated_at
`

type CreateWithdrawalQueueItemParams struct {
	ClientID                uuid.UUID      `db:"client_id"`
	WithdrawalTransactionID uuid.UUID      `db:"withdrawal_transaction_id"`
	EndUserVaultID          uuid.UUID      `db:"end_user_vault_id"`
	SharesToBurn            pgtype.Numeric `db:"shares_to_burn"`
	EstimatedAmount         pgtype.Numeric `db:"estimated_amount"`
	ProtocolsToUnstake      []byte         `db:"protocols_to_unstake"`
	Priority                int32          `db:"priority"`
	Status                  string         `db:"status"`
}

func (q *Queries) CreateWithdrawalQueueItem(ctx context.Context, arg CreateWithdrawalQueueItemParams) (WithdrawalQueue, error) {
	row := q.db.QueryRow(ctx, createWithdrawalQueueItem,
		arg.ClientID,
		arg.WithdrawalTransactionID,
		arg.EndUserVaultID,
		arg.SharesToBurn,
		arg.EstimatedAmount,
		arg.ProtocolsToUnstake,
		arg.Priority,
		arg.Status,
	)
	var i WithdrawalQueue
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.WithdrawalTransactionID,
		&i.EndUserVaultID,
		&i.SharesToBurn,
		&i.EstimatedAmount,
		&i.ActualAmount,
		&i.ProtocolsToUnstake,
		&i.Priority,
		&i.Status,
		&i.QueuedAt,
		&i.UnstakingStartedAt,
		&i.ReadyAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const failWithdrawal = `-- name: FailWithdrawal :exec
UPDATE withdrawal_transactions
SET status = 'failed',
    error_message = $2,
    error_code = $3,
    failed_at = now()
WHERE id = $1
`

type FailWithdrawalParams struct {
	ID           uuid.UUID `db:"id"`
	ErrorMessage *string   `db:"error_message"`
	ErrorCode    *string   `db:"error_code"`
}

// Mark withdrawal as failed
func (q *Queries) FailWithdrawal(ctx context.Context, arg FailWithdrawalParams) error {
	_, err := q.db.Exec(ctx, failWithdrawal, arg.ID, arg.ErrorMessage, arg.ErrorCode)
	return err
}

const failWithdrawalQueue = `-- name: FailWithdrawalQueue :exec
UPDATE withdrawal_queue
SET status = 'failed',
    error_message = $2,
    updated_at = now()
WHERE id = $1
`

type FailWithdrawalQueueParams struct {
	ID           uuid.UUID `db:"id"`
	ErrorMessage *string   `db:"error_message"`
}

func (q *Queries) FailWithdrawalQueue(ctx context.Context, arg FailWithdrawalQueueParams) error {
	_, err := q.db.Exec(ctx, failWithdrawalQueue, arg.ID, arg.ErrorMessage)
	return err
}

const getAggregatedUnstakingPlan = `-- name: GetAggregatedUnstakingPlan :many
SELECT
  wq.client_id,
  da.protocol_id,
  sdp.name AS protocol_name,
  da.chain,
  da.token_address,
  da.token_symbol,
  jsonb_agg(
    jsonb_build_object(
      'withdrawal_queue_id', wq.id,
      'withdrawal_transaction_id', wq.withdrawal_transaction_id,
      'amount', (wq.protocols_to_unstake->0->>'amount')::numeric
    )
  ) AS withdrawals,
  SUM((wq.protocols_to_unstake->0->>'amount')::numeric) AS total_to_unstake
FROM withdrawal_queue wq
JOIN end_user_vaults euv ON wq.end_user_vault_id = euv.id
JOIN client_vaults cv
  ON euv.client_id = cv.client_id
  AND euv.chain = cv.chain
  AND euv.token_address = cv.token_address
JOIN defi_allocations da
  ON da.client_vault_id = cv.id
  AND da.status = 'active'
JOIN supported_defi_protocols sdp ON da.protocol_id = sdp.id
WHERE wq.status = 'queued'
  AND wq.client_id = $1
GROUP BY wq.client_id, da.protocol_id, sdp.name, da.chain, da.token_address, da.token_symbol
ORDER BY total_to_unstake DESC
`

type GetAggregatedUnstakingPlanRow struct {
	ClientID       uuid.UUID `db:"client_id"`
	ProtocolID     uuid.UUID `db:"protocol_id"`
	ProtocolName   string    `db:"protocol_name"`
	Chain          string    `db:"chain"`
	TokenAddress   string    `db:"token_address"`
	TokenSymbol    string    `db:"token_symbol"`
	Withdrawals    []byte    `db:"withdrawals"`
	TotalToUnstake int64     `db:"total_to_unstake"`
}

// Aggregate withdrawal amounts by protocol for batch unstaking
func (q *Queries) GetAggregatedUnstakingPlan(ctx context.Context, clientID uuid.UUID) ([]GetAggregatedUnstakingPlanRow, error) {
	rows, err := q.db.Query(ctx, getAggregatedUnstakingPlan, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregatedUnstakingPlanRow
	for rows.Next() {
		var i GetAggregatedUnstakingPlanRow
		if err := rows.Scan(
			&i.ClientID,
			&i.ProtocolID,
			&i.ProtocolName,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.Withdrawals,
			&i.TotalToUnstake,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWithdrawal = `-- name: GetWithdrawal :one

SELECT id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code FROM withdrawal_transactions
WHERE id = $1 LIMIT 1
`

// ============================================
// WITHDRAWAL TRANSACTION QUERIES
// ============================================
func (q *Queries) GetWithdrawal(ctx context.Context, id uuid.UUID) (WithdrawalTransaction, error) {
	row := q.db.QueryRow(ctx, getWithdrawal, id)
	var i WithdrawalTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.RequestedAmount,
		&i.ActualAmount,
		&i.Currency,
		&i.WithdrawalFee,
		&i.NetworkFee,
		&i.GatewayOrderID,
		&i.DestinationType,
		&i.DestinationDetails,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getWithdrawalByGatewayOrderID = `-- name: GetWithdrawalByGatewayOrderID :one
SELECT id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code FROM withdrawal_transactions
WHERE gateway_order_id = $1 LIMIT 1
`

func (q *Queries) GetWithdrawalByGatewayOrderID(ctx context.Context, gatewayOrderID *string) (WithdrawalTransaction, error) {
	row := q.db.QueryRow(ctx, getWithdrawalByGatewayOrderID, gatewayOrderID)
	var i WithdrawalTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.RequestedAmount,
		&i.ActualAmount,
		&i.Currency,
		&i.WithdrawalFee,
		&i.NetworkFee,
		&i.GatewayOrderID,
		&i.DestinationType,
		&i.DestinationDetails,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getWithdrawalByOrderID = `-- name: GetWithdrawalByOrderID :one
SELECT id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code FROM withdrawal_transactions
WHERE order_id = $1 LIMIT 1
`

func (q *Queries) GetWithdrawalByOrderID(ctx context.Context, orderID string) (WithdrawalTransaction, error) {
	row := q.db.QueryRow(ctx, getWithdrawalByOrderID, orderID)
	var i WithdrawalTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.RequestedAmount,
		&i.ActualAmount,
		&i.Currency,
		&i.WithdrawalFee,
		&i.NetworkFee,
		&i.GatewayOrderID,
		&i.DestinationType,
		&i.DestinationDetails,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getWithdrawalByOrderIDForUpdate = `-- name: GetWithdrawalByOrderIDForUpdate :one
SELECT id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code FROM withdrawal_transactions
WHERE order_id = $1
FOR UPDATE
LIMIT 1
`

// Use in transactions to lock the withdrawal row
func (q *Queries) GetWithdrawalByOrderIDForUpdate(ctx context.Context, orderID string) (WithdrawalTransaction, error) {
	row := q.db.QueryRow(ctx, getWithdrawalByOrderIDForUpdate, orderID)
	var i WithdrawalTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.RequestedAmount,
		&i.ActualAmount,
		&i.Currency,
		&i.WithdrawalFee,
		&i.NetworkFee,
		&i.GatewayOrderID,
		&i.DestinationType,
		&i.DestinationDetails,
		&i.Status,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getWithdrawalQueueByTransaction = `-- name: GetWithdrawalQueueByTransaction :one
SELECT id, client_id, withdrawal_transaction_id, end_user_vault_id, shares_to_burn, estimated_amount, actual_amount, protocols_to_unstake, priority, status, queued_at, unstaking_started_at, ready_at, completed_at, error_message, created_at, updated_at FROM withdrawal_queue
WHERE withdrawal_transaction_id = $1 LIMIT 1
`

func (q *Queries) GetWithdrawalQueueByTransaction(ctx context.Context, withdrawalTransactionID uuid.UUID) (WithdrawalQueue, error) {
	row := q.db.QueryRow(ctx, getWithdrawalQueueByTransaction, withdrawalTransactionID)
	var i WithdrawalQueue
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.WithdrawalTransactionID,
		&i.EndUserVaultID,
		&i.SharesToBurn,
		&i.EstimatedAmount,
		&i.ActualAmount,
		&i.ProtocolsToUnstake,
		&i.Priority,
		&i.Status,
		&i.QueuedAt,
		&i.UnstakingStartedAt,
		&i.ReadyAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWithdrawalQueueItem = `-- name: GetWithdrawalQueueItem :one

SELECT id, client_id, withdrawal_transaction_id, end_user_vault_id, shares_to_burn, estimated_amount, actual_amount, protocols_to_unstake, priority, status, queued_at, unstaking_started_at, ready_at, completed_at, error_message, created_at, updated_at FROM withdrawal_queue
WHERE id = $1 LIMIT 1
`

// ============================================
// WITHDRAWAL QUEUE QUERIES
// ============================================
func (q *Queries) GetWithdrawalQueueItem(ctx context.Context, id uuid.UUID) (WithdrawalQueue, error) {
	row := q.db.QueryRow(ctx, getWithdrawalQueueItem, id)
	var i WithdrawalQueue
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.WithdrawalTransactionID,
		&i.EndUserVaultID,
		&i.SharesToBurn,
		&i.EstimatedAmount,
		&i.ActualAmount,
		&i.ProtocolsToUnstake,
		&i.Priority,
		&i.Status,
		&i.QueuedAt,
		&i.UnstakingStartedAt,
		&i.ReadyAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWithdrawalStats = `-- name: GetWithdrawalStats :one

SELECT
  COUNT(*) AS total_withdrawals,
  COUNT(*) FILTER (WHERE status = 'completed') AS completed_withdrawals,
  COUNT(*) FILTER (WHERE status = 'pending') AS pending_withdrawals,
  COUNT(*) FILTER (WHERE status = 'failed') AS failed_withdrawals,
  COALESCE(SUM(actual_amount) FILTER (WHERE status = 'completed'), 0) AS total_volume,
  COALESCE(SUM(withdrawal_fee) FILTER (WHERE status = 'completed'), 0) AS total_fees_collected,
  COALESCE(AVG(actual_amount) FILTER (WHERE status = 'completed'), 0) AS avg_withdrawal_amount
FROM withdrawal_transactions
WHERE client_id = $1
  AND created_at >= $2  -- start date
  AND created_at <= $3
`

type GetWithdrawalStatsParams struct {
	ClientID  uuid.UUID          `db:"client_id"`
	StartDate pgtype.Timestamptz `db:"start_date"`
	EndDate   pgtype.Timestamptz `db:"end_date"`
}

type GetWithdrawalStatsRow struct {
	TotalWithdrawals     int64       `db:"total_withdrawals"`
	CompletedWithdrawals int64       `db:"completed_withdrawals"`
	PendingWithdrawals   int64       `db:"pending_withdrawals"`
	FailedWithdrawals    int64       `db:"failed_withdrawals"`
	TotalVolume          interface{} `db:"total_volume"`
	TotalFeesCollected   interface{} `db:"total_fees_collected"`
	AvgWithdrawalAmount  interface{} `db:"avg_withdrawal_amount"`
}

// ============================================
// WITHDRAWAL ANALYTICS
// ============================================
// Withdrawal statistics for a client
func (q *Queries) GetWithdrawalStats(ctx context.Context, arg GetWithdrawalStatsParams) (GetWithdrawalStatsRow, error) {
	row := q.db.QueryRow(ctx, getWithdrawalStats, arg.ClientID, arg.StartDate, arg.EndDate)
	var i GetWithdrawalStatsRow
	err := row.Scan(
		&i.TotalWithdrawals,
		&i.CompletedWithdrawals,
		&i.PendingWithdrawals,
		&i.FailedWithdrawals,
		&i.TotalVolume,
		&i.TotalFeesCollected,
		&i.AvgWithdrawalAmount,
	)
	return i, err
}

const listQueuedWithdrawals = `-- name: ListQueuedWithdrawals :many
SELECT id, client_id, withdrawal_transaction_id, end_user_vault_id, shares_to_burn, estimated_amount, actual_amount, protocols_to_unstake, priority, status, queued_at, unstaking_started_at, ready_at, completed_at, error_message, created_at, updated_at FROM withdrawal_queue
WHERE status = 'queued'
ORDER BY priority DESC, queued_at ASC
LIMIT $1
`

// Get withdrawals queued for processing (by priority)
func (q *Queries) ListQueuedWithdrawals(ctx context.Context, limit int32) ([]WithdrawalQueue, error) {
	rows, err := q.db.Query(ctx, listQueuedWithdrawals, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WithdrawalQueue
	for rows.Next() {
		var i WithdrawalQueue
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.WithdrawalTransactionID,
			&i.EndUserVaultID,
			&i.SharesToBurn,
			&i.EstimatedAmount,
			&i.ActualAmount,
			&i.ProtocolsToUnstake,
			&i.Priority,
			&i.Status,
			&i.QueuedAt,
			&i.UnstakingStartedAt,
			&i.ReadyAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithdrawalQueueByVault = `-- name: ListWithdrawalQueueByVault :many
SELECT id, client_id, withdrawal_transaction_id, end_user_vault_id, shares_to_burn, estimated_amount, actual_amount, protocols_to_unstake, priority, status, queued_at, unstaking_started_at, ready_at, completed_at, error_message, created_at, updated_at FROM withdrawal_queue
WHERE end_user_vault_id = $1
ORDER BY queued_at DESC
`

// Get withdrawal queue for a specific user vault
func (q *Queries) ListWithdrawalQueueByVault(ctx context.Context, endUserVaultID uuid.UUID) ([]WithdrawalQueue, error) {
	rows, err := q.db.Query(ctx, listWithdrawalQueueByVault, endUserVaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WithdrawalQueue
	for rows.Next() {
		var i WithdrawalQueue
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.WithdrawalTransactionID,
			&i.EndUserVaultID,
			&i.SharesToBurn,
			&i.EstimatedAmount,
			&i.ActualAmount,
			&i.ProtocolsToUnstake,
			&i.Priority,
			&i.Status,
			&i.QueuedAt,
			&i.UnstakingStartedAt,
			&i.ReadyAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithdrawals = `-- name: ListWithdrawals :many
SELECT id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code FROM withdrawal_transactions
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWithdrawalsParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListWithdrawals(ctx context.Context, arg ListWithdrawalsParams) ([]WithdrawalTransaction, error) {
	rows, err := q.db.Query(ctx, listWithdrawals, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WithdrawalTransaction
	for rows.Next() {
		var i WithdrawalTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.RequestedAmount,
			&i.ActualAmount,
			&i.Currency,
			&i.WithdrawalFee,
			&i.NetworkFee,
			&i.GatewayOrderID,
			&i.DestinationType,
			&i.DestinationDetails,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithdrawalsByStatus = `-- name: ListWithdrawalsByStatus :many
SELECT id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code FROM withdrawal_transactions
WHERE client_id = $1
  AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListWithdrawalsByStatusParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Status   string    `db:"status"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListWithdrawalsByStatus(ctx context.Context, arg ListWithdrawalsByStatusParams) ([]WithdrawalTransaction, error) {
	rows, err := q.db.Query(ctx, listWithdrawalsByStatus,
		arg.ClientID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WithdrawalTransaction
	for rows.Next() {
		var i WithdrawalTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.RequestedAmount,
			&i.ActualAmount,
			&i.Currency,
			&i.WithdrawalFee,
			&i.NetworkFee,
			&i.GatewayOrderID,
			&i.DestinationType,
			&i.DestinationDetails,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithdrawalsByUser = `-- name: ListWithdrawalsByUser :many
SELECT id, order_id, client_id, user_id, requested_amount, actual_amount, currency, withdrawal_fee, network_fee, gateway_order_id, destination_type, destination_details, status, created_at, completed_at, failed_at, error_message, error_code FROM withdrawal_transactions
WHERE client_id = $1
  AND user_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListWithdrawalsByUserParams struct {
	ClientID uuid.UUID `db:"client_id"`
	UserID   string    `db:"user_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListWithdrawalsByUser(ctx context.Context, arg ListWithdrawalsByUserParams) ([]WithdrawalTransaction, error) {
	rows, err := q.db.Query(ctx, listWithdrawalsByUser,
		arg.ClientID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WithdrawalTransaction
	for rows.Next() {
		var i WithdrawalTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.RequestedAmount,
			&i.ActualAmount,
			&i.Currency,
			&i.WithdrawalFee,
			&i.NetworkFee,
			&i.GatewayOrderID,
			&i.DestinationType,
			&i.DestinationDetails,
			&i.Status,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWithdrawalProcessing = `-- name: MarkWithdrawalProcessing :exec
UPDATE withdrawal_queue
SET status = 'processing',
    updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkWithdrawalProcessing(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markWithdrawalProcessing, id)
	return err
}

const markWithdrawalReady = `-- name: MarkWithdrawalReady :exec
UPDATE withdrawal_queue
SET status = 'ready',
    actual_amount = $2,
    ready_at = now(),
    updated_at = now()
WHERE id = $1
`

type MarkWithdrawalReadyParams struct {
	ID           uuid.UUID      `db:"id"`
	ActualAmount pgtype.Numeric `db:"actual_amount"`
}

// Mark as ready after unstaking completes
func (q *Queries) MarkWithdrawalReady(ctx context.Context, arg MarkWithdrawalReadyParams) error {
	_, err := q.db.Exec(ctx, markWithdrawalReady, arg.ID, arg.ActualAmount)
	return err
}

const startUnstaking = `-- name: StartUnstaking :exec
UPDATE withdrawal_queue
SET status = 'unstaking',
    unstaking_started_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) StartUnstaking(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, startUnstaking, id)
	return err
}

const updateWithdrawalGatewayInfo = `-- name: UpdateWithdrawalGatewayInfo :exec
UPDATE withdrawal_transactions
SET gateway_order_id = $2,
    withdrawal_fee = COALESCE($3, withdrawal_fee),
    network_fee = COALESCE($4, network_fee),
    updated_at = now()
WHERE id = $1
`

type UpdateWithdrawalGatewayInfoParams struct {
	ID             uuid.UUID      `db:"id"`
	GatewayOrderID *string        `db:"gateway_order_id"`
	WithdrawalFee  pgtype.Numeric `db:"withdrawal_fee"`
	NetworkFee     pgtype.Numeric `db:"network_fee"`
}

// Update after initiating off-ramp
func (q *Queries) UpdateWithdrawalGatewayInfo(ctx context.Context, arg UpdateWithdrawalGatewayInfoParams) error {
	_, err := q.db.Exec(ctx, updateWithdrawalGatewayInfo,
		arg.ID,
		arg.GatewayOrderID,
		arg.WithdrawalFee,
		arg.NetworkFee,
	)
	return err
}

const updateWithdrawalQueueStatus = `-- name: UpdateWithdrawalQueueStatus :exec
UPDATE withdrawal_queue
SET status = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateWithdrawalQueueStatusParams struct {
	ID     uuid.UUID `db:"id"`
	Status string    `db:"status"`
}

func (q *Queries) UpdateWithdrawalQueueStatus(ctx context.Context, arg UpdateWithdrawalQueueStatusParams) error {
	_, err := q.db.Exec(ctx, updateWithdrawalQueueStatus, arg.ID, arg.Status)
	return err
}

const updateWithdrawalStatus = `-- name: UpdateWithdrawalStatus :exec
UPDATE withdrawal_transactions
SET status = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateWithdrawalStatusParams struct {
	ID     uuid.UUID `db:"id"`
	Status string    `db:"status"`
}

func (q *Queries) UpdateWithdrawalStatus(ctx context.Context, arg UpdateWithdrawalStatusParams) error {
	_, err := q.db.Exec(ctx, updateWithdrawalStatus, arg.ID, arg.Status)
	return err
}
