// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: deposit.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeDeposit = `-- name: CompleteDeposit :one
UPDATE deposit_transactions
SET status = 'completed',
    crypto_amount = COALESCE($2, crypto_amount),
    gateway_fee = COALESCE($3, gateway_fee),
    proxify_fee = COALESCE($4, proxify_fee),
    network_fee = COALESCE($5, network_fee),
    total_fees = COALESCE($6, total_fees),
    completed_at = now()
WHERE id = $1
RETURNING id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code
`

type CompleteDepositParams struct {
	ID           uuid.UUID      `db:"id"`
	CryptoAmount pgtype.Numeric `db:"crypto_amount"`
	GatewayFee   pgtype.Numeric `db:"gateway_fee"`
	ProxifyFee   pgtype.Numeric `db:"proxify_fee"`
	NetworkFee   pgtype.Numeric `db:"network_fee"`
	TotalFees    pgtype.Numeric `db:"total_fees"`
}

// Mark deposit as completed
func (q *Queries) CompleteDeposit(ctx context.Context, arg CompleteDepositParams) (DepositTransaction, error) {
	row := q.db.QueryRow(ctx, completeDeposit,
		arg.ID,
		arg.CryptoAmount,
		arg.GatewayFee,
		arg.ProxifyFee,
		arg.NetworkFee,
		arg.TotalFees,
	)
	var i DepositTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.DepositType,
		&i.PaymentMethod,
		&i.FiatAmount,
		&i.CryptoAmount,
		&i.Currency,
		&i.CryptoCurrency,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.Status,
		&i.PaymentUrl,
		&i.GatewayOrderID,
		&i.ClientBalanceID,
		&i.DeductedFromClient,
		&i.WalletAddress,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ExpiresAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const createDeposit = `-- name: CreateDeposit :one
INSERT INTO deposit_transactions (
  order_id,
  client_id,
  user_id,
  deposit_type,
  payment_method,
  fiat_amount,
  crypto_amount,
  currency,
  crypto_currency,
  gateway_fee,
  proxify_fee,
  network_fee,
  total_fees,
  status,
  payment_url,
  gateway_order_id,
  client_balance_id,
  deducted_from_client,
  wallet_address,
  expires_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
  $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
)
RETURNING id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code
`

type CreateDepositParams struct {
	OrderID            string             `db:"order_id"`
	ClientID           uuid.UUID          `db:"client_id"`
	UserID             string             `db:"user_id"`
	DepositType        string             `db:"deposit_type"`
	PaymentMethod      *string            `db:"payment_method"`
	FiatAmount         pgtype.Numeric     `db:"fiat_amount"`
	CryptoAmount       pgtype.Numeric     `db:"crypto_amount"`
	Currency           string             `db:"currency"`
	CryptoCurrency     *string            `db:"crypto_currency"`
	GatewayFee         pgtype.Numeric     `db:"gateway_fee"`
	ProxifyFee         pgtype.Numeric     `db:"proxify_fee"`
	NetworkFee         pgtype.Numeric     `db:"network_fee"`
	TotalFees          pgtype.Numeric     `db:"total_fees"`
	Status             string             `db:"status"`
	PaymentUrl         *string            `db:"payment_url"`
	GatewayOrderID     *string            `db:"gateway_order_id"`
	ClientBalanceID    pgtype.UUID        `db:"client_balance_id"`
	DeductedFromClient pgtype.Numeric     `db:"deducted_from_client"`
	WalletAddress      *string            `db:"wallet_address"`
	ExpiresAt          pgtype.Timestamptz `db:"expires_at"`
}

func (q *Queries) CreateDeposit(ctx context.Context, arg CreateDepositParams) (DepositTransaction, error) {
	row := q.db.QueryRow(ctx, createDeposit,
		arg.OrderID,
		arg.ClientID,
		arg.UserID,
		arg.DepositType,
		arg.PaymentMethod,
		arg.FiatAmount,
		arg.CryptoAmount,
		arg.Currency,
		arg.CryptoCurrency,
		arg.GatewayFee,
		arg.ProxifyFee,
		arg.NetworkFee,
		arg.TotalFees,
		arg.Status,
		arg.PaymentUrl,
		arg.GatewayOrderID,
		arg.ClientBalanceID,
		arg.DeductedFromClient,
		arg.WalletAddress,
		arg.ExpiresAt,
	)
	var i DepositTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.DepositType,
		&i.PaymentMethod,
		&i.FiatAmount,
		&i.CryptoAmount,
		&i.Currency,
		&i.CryptoCurrency,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.Status,
		&i.PaymentUrl,
		&i.GatewayOrderID,
		&i.ClientBalanceID,
		&i.DeductedFromClient,
		&i.WalletAddress,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ExpiresAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const createDepositQueueItem = `-- name: CreateDepositQueueItem :one
INSERT INTO deposit_batch_queue (
  client_vault_id,
  deposit_transaction_id,
  amount,
  status
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, client_vault_id, deposit_transaction_id, amount, status, batched_at, staked_at, created_at
`

type CreateDepositQueueItemParams struct {
	ClientVaultID        uuid.UUID      `db:"client_vault_id"`
	DepositTransactionID uuid.UUID      `db:"deposit_transaction_id"`
	Amount               pgtype.Numeric `db:"amount"`
	Status               string         `db:"status"`
}

func (q *Queries) CreateDepositQueueItem(ctx context.Context, arg CreateDepositQueueItemParams) (DepositBatchQueue, error) {
	row := q.db.QueryRow(ctx, createDepositQueueItem,
		arg.ClientVaultID,
		arg.DepositTransactionID,
		arg.Amount,
		arg.Status,
	)
	var i DepositBatchQueue
	err := row.Scan(
		&i.ID,
		&i.ClientVaultID,
		&i.DepositTransactionID,
		&i.Amount,
		&i.Status,
		&i.BatchedAt,
		&i.StakedAt,
		&i.CreatedAt,
	)
	return i, err
}

const expireDeposit = `-- name: ExpireDeposit :exec
UPDATE deposit_transactions
SET status = 'expired'
WHERE id = $1
`

// Mark deposit as expired
func (q *Queries) ExpireDeposit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, expireDeposit, id)
	return err
}

const failDeposit = `-- name: FailDeposit :exec
UPDATE deposit_transactions
SET status = 'failed',
    error_message = $2,
    error_code = $3,
    failed_at = now()
WHERE id = $1
`

type FailDepositParams struct {
	ID           uuid.UUID `db:"id"`
	ErrorMessage *string   `db:"error_message"`
	ErrorCode    *string   `db:"error_code"`
}

// Mark deposit as failed
func (q *Queries) FailDeposit(ctx context.Context, arg FailDepositParams) error {
	_, err := q.db.Exec(ctx, failDeposit, arg.ID, arg.ErrorMessage, arg.ErrorCode)
	return err
}

const getDeposit = `-- name: GetDeposit :one

SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE id = $1 LIMIT 1
`

// ============================================
// DEPOSIT TRANSACTION QUERIES
// ============================================
func (q *Queries) GetDeposit(ctx context.Context, id uuid.UUID) (DepositTransaction, error) {
	row := q.db.QueryRow(ctx, getDeposit, id)
	var i DepositTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.DepositType,
		&i.PaymentMethod,
		&i.FiatAmount,
		&i.CryptoAmount,
		&i.Currency,
		&i.CryptoCurrency,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.Status,
		&i.PaymentUrl,
		&i.GatewayOrderID,
		&i.ClientBalanceID,
		&i.DeductedFromClient,
		&i.WalletAddress,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ExpiresAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getDepositByGatewayOrderID = `-- name: GetDepositByGatewayOrderID :one
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE gateway_order_id = $1 LIMIT 1
`

func (q *Queries) GetDepositByGatewayOrderID(ctx context.Context, gatewayOrderID *string) (DepositTransaction, error) {
	row := q.db.QueryRow(ctx, getDepositByGatewayOrderID, gatewayOrderID)
	var i DepositTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.DepositType,
		&i.PaymentMethod,
		&i.FiatAmount,
		&i.CryptoAmount,
		&i.Currency,
		&i.CryptoCurrency,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.Status,
		&i.PaymentUrl,
		&i.GatewayOrderID,
		&i.ClientBalanceID,
		&i.DeductedFromClient,
		&i.WalletAddress,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ExpiresAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getDepositByOrderID = `-- name: GetDepositByOrderID :one
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE order_id = $1 LIMIT 1
`

func (q *Queries) GetDepositByOrderID(ctx context.Context, orderID string) (DepositTransaction, error) {
	row := q.db.QueryRow(ctx, getDepositByOrderID, orderID)
	var i DepositTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.DepositType,
		&i.PaymentMethod,
		&i.FiatAmount,
		&i.CryptoAmount,
		&i.Currency,
		&i.CryptoCurrency,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.Status,
		&i.PaymentUrl,
		&i.GatewayOrderID,
		&i.ClientBalanceID,
		&i.DeductedFromClient,
		&i.WalletAddress,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ExpiresAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getDepositByOrderIDForUpdate = `-- name: GetDepositByOrderIDForUpdate :one
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE order_id = $1
FOR UPDATE
LIMIT 1
`

// Use in transactions to lock the deposit row
func (q *Queries) GetDepositByOrderIDForUpdate(ctx context.Context, orderID string) (DepositTransaction, error) {
	row := q.db.QueryRow(ctx, getDepositByOrderIDForUpdate, orderID)
	var i DepositTransaction
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ClientID,
		&i.UserID,
		&i.DepositType,
		&i.PaymentMethod,
		&i.FiatAmount,
		&i.CryptoAmount,
		&i.Currency,
		&i.CryptoCurrency,
		&i.GatewayFee,
		&i.ProxifyFee,
		&i.NetworkFee,
		&i.TotalFees,
		&i.Status,
		&i.PaymentUrl,
		&i.GatewayOrderID,
		&i.ClientBalanceID,
		&i.DeductedFromClient,
		&i.WalletAddress,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ExpiresAt,
		&i.ErrorMessage,
		&i.ErrorCode,
	)
	return i, err
}

const getDepositQueueItem = `-- name: GetDepositQueueItem :one

SELECT id, client_vault_id, deposit_transaction_id, amount, status, batched_at, staked_at, created_at FROM deposit_batch_queue
WHERE id = $1 LIMIT 1
`

// ============================================
// DEPOSIT BATCH QUEUE QUERIES
// ============================================
func (q *Queries) GetDepositQueueItem(ctx context.Context, id uuid.UUID) (DepositBatchQueue, error) {
	row := q.db.QueryRow(ctx, getDepositQueueItem, id)
	var i DepositBatchQueue
	err := row.Scan(
		&i.ID,
		&i.ClientVaultID,
		&i.DepositTransactionID,
		&i.Amount,
		&i.Status,
		&i.BatchedAt,
		&i.StakedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getDepositStats = `-- name: GetDepositStats :one

SELECT
  COUNT(*) AS total_deposits,
  COUNT(*) FILTER (WHERE status = 'completed') AS completed_deposits,
  COUNT(*) FILTER (WHERE status = 'pending') AS pending_deposits,
  COUNT(*) FILTER (WHERE status = 'failed') AS failed_deposits,
  COALESCE(SUM(crypto_amount) FILTER (WHERE status = 'completed'), 0) AS total_volume,
  COALESCE(SUM(total_fees) FILTER (WHERE status = 'completed'), 0) AS total_fees_collected,
  COALESCE(AVG(crypto_amount) FILTER (WHERE status = 'completed'), 0) AS avg_deposit_amount
FROM deposit_transactions
WHERE client_id = $1
  AND created_at >= $2  -- start date
  AND created_at <= $3
`

type GetDepositStatsParams struct {
	ClientID    uuid.UUID          `db:"client_id"`
	CreatedAt   pgtype.Timestamptz `db:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `db:"created_at_2"`
}

type GetDepositStatsRow struct {
	TotalDeposits      int64       `db:"total_deposits"`
	CompletedDeposits  int64       `db:"completed_deposits"`
	PendingDeposits    int64       `db:"pending_deposits"`
	FailedDeposits     int64       `db:"failed_deposits"`
	TotalVolume        interface{} `db:"total_volume"`
	TotalFeesCollected interface{} `db:"total_fees_collected"`
	AvgDepositAmount   interface{} `db:"avg_deposit_amount"`
}

// ============================================
// DEPOSIT ANALYTICS
// ============================================
// Deposit statistics for a client
func (q *Queries) GetDepositStats(ctx context.Context, arg GetDepositStatsParams) (GetDepositStatsRow, error) {
	row := q.db.QueryRow(ctx, getDepositStats, arg.ClientID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetDepositStatsRow
	err := row.Scan(
		&i.TotalDeposits,
		&i.CompletedDeposits,
		&i.PendingDeposits,
		&i.FailedDeposits,
		&i.TotalVolume,
		&i.TotalFeesCollected,
		&i.AvgDepositAmount,
	)
	return i, err
}

const listDeposits = `-- name: ListDeposits :many
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDepositsParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListDeposits(ctx context.Context, arg ListDepositsParams) ([]DepositTransaction, error) {
	rows, err := q.db.Query(ctx, listDeposits, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositTransaction
	for rows.Next() {
		var i DepositTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.DepositType,
			&i.PaymentMethod,
			&i.FiatAmount,
			&i.CryptoAmount,
			&i.Currency,
			&i.CryptoCurrency,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.Status,
			&i.PaymentUrl,
			&i.GatewayOrderID,
			&i.ClientBalanceID,
			&i.DeductedFromClient,
			&i.WalletAddress,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ExpiresAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDepositsByStatus = `-- name: ListDepositsByStatus :many
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE client_id = $1
  AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListDepositsByStatusParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Status   string    `db:"status"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListDepositsByStatus(ctx context.Context, arg ListDepositsByStatusParams) ([]DepositTransaction, error) {
	rows, err := q.db.Query(ctx, listDepositsByStatus,
		arg.ClientID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositTransaction
	for rows.Next() {
		var i DepositTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.DepositType,
			&i.PaymentMethod,
			&i.FiatAmount,
			&i.CryptoAmount,
			&i.Currency,
			&i.CryptoCurrency,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.Status,
			&i.PaymentUrl,
			&i.GatewayOrderID,
			&i.ClientBalanceID,
			&i.DeductedFromClient,
			&i.WalletAddress,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ExpiresAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDepositsByUser = `-- name: ListDepositsByUser :many
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE client_id = $1
  AND user_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListDepositsByUserParams struct {
	ClientID uuid.UUID `db:"client_id"`
	UserID   string    `db:"user_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListDepositsByUser(ctx context.Context, arg ListDepositsByUserParams) ([]DepositTransaction, error) {
	rows, err := q.db.Query(ctx, listDepositsByUser,
		arg.ClientID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositTransaction
	for rows.Next() {
		var i DepositTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.DepositType,
			&i.PaymentMethod,
			&i.FiatAmount,
			&i.CryptoAmount,
			&i.Currency,
			&i.CryptoCurrency,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.Status,
			&i.PaymentUrl,
			&i.GatewayOrderID,
			&i.ClientBalanceID,
			&i.DeductedFromClient,
			&i.WalletAddress,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ExpiresAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiredDeposits = `-- name: ListExpiredDeposits :many
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE status = 'pending'
  AND expires_at <= now()
ORDER BY created_at ASC
LIMIT $1
`

// Get pending deposits that have expired
func (q *Queries) ListExpiredDeposits(ctx context.Context, limit int32) ([]DepositTransaction, error) {
	rows, err := q.db.Query(ctx, listExpiredDeposits, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositTransaction
	for rows.Next() {
		var i DepositTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.DepositType,
			&i.PaymentMethod,
			&i.FiatAmount,
			&i.CryptoAmount,
			&i.Currency,
			&i.CryptoCurrency,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.Status,
			&i.PaymentUrl,
			&i.GatewayOrderID,
			&i.ClientBalanceID,
			&i.DeductedFromClient,
			&i.WalletAddress,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ExpiresAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDepositQueue = `-- name: ListPendingDepositQueue :many
SELECT id, client_vault_id, deposit_transaction_id, amount, status, batched_at, staked_at, created_at FROM deposit_batch_queue
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT $1
`

// Get deposits waiting to be batched
func (q *Queries) ListPendingDepositQueue(ctx context.Context, limit int32) ([]DepositBatchQueue, error) {
	rows, err := q.db.Query(ctx, listPendingDepositQueue, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositBatchQueue
	for rows.Next() {
		var i DepositBatchQueue
		if err := rows.Scan(
			&i.ID,
			&i.ClientVaultID,
			&i.DepositTransactionID,
			&i.Amount,
			&i.Status,
			&i.BatchedAt,
			&i.StakedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDepositQueueByVault = `-- name: ListPendingDepositQueueByVault :many
SELECT id, client_vault_id, deposit_transaction_id, amount, status, batched_at, staked_at, created_at FROM deposit_batch_queue
WHERE client_vault_id = $1
  AND status = 'pending'
ORDER BY created_at ASC
`

// Get pending deposits for a specific vault
func (q *Queries) ListPendingDepositQueueByVault(ctx context.Context, clientVaultID uuid.UUID) ([]DepositBatchQueue, error) {
	rows, err := q.db.Query(ctx, listPendingDepositQueueByVault, clientVaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositBatchQueue
	for rows.Next() {
		var i DepositBatchQueue
		if err := rows.Scan(
			&i.ID,
			&i.ClientVaultID,
			&i.DepositTransactionID,
			&i.Amount,
			&i.Status,
			&i.BatchedAt,
			&i.StakedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDeposits = `-- name: ListPendingDeposits :many
SELECT id, order_id, client_id, user_id, deposit_type, payment_method, fiat_amount, crypto_amount, currency, crypto_currency, gateway_fee, proxify_fee, network_fee, total_fees, status, payment_url, gateway_order_id, client_balance_id, deducted_from_client, wallet_address, created_at, completed_at, failed_at, expires_at, error_message, error_code FROM deposit_transactions
WHERE status = 'pending'
  AND expires_at > now()
ORDER BY created_at ASC
`

// Get pending deposits that haven't expired
func (q *Queries) ListPendingDeposits(ctx context.Context) ([]DepositTransaction, error) {
	rows, err := q.db.Query(ctx, listPendingDeposits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DepositTransaction
	for rows.Next() {
		var i DepositTransaction
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ClientID,
			&i.UserID,
			&i.DepositType,
			&i.PaymentMethod,
			&i.FiatAmount,
			&i.CryptoAmount,
			&i.Currency,
			&i.CryptoCurrency,
			&i.GatewayFee,
			&i.ProxifyFee,
			&i.NetworkFee,
			&i.TotalFees,
			&i.Status,
			&i.PaymentUrl,
			&i.GatewayOrderID,
			&i.ClientBalanceID,
			&i.DeductedFromClient,
			&i.WalletAddress,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ExpiresAt,
			&i.ErrorMessage,
			&i.ErrorCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDepositAsBatched = `-- name: MarkDepositAsBatched :exec
UPDATE deposit_batch_queue
SET status = 'batched',
    batched_at = now()
WHERE id = $1
`

func (q *Queries) MarkDepositAsBatched(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDepositAsBatched, id)
	return err
}

const markDepositAsStaked = `-- name: MarkDepositAsStaked :exec
UPDATE deposit_batch_queue
SET status = 'staked',
    staked_at = now()
WHERE id = $1
`

func (q *Queries) MarkDepositAsStaked(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDepositAsStaked, id)
	return err
}

const markDepositBatchAsStaked = `-- name: MarkDepositBatchAsStaked :exec
UPDATE deposit_batch_queue
SET status = 'staked',
    staked_at = now()
WHERE client_vault_id = $1
  AND status = 'batched'
`

// Batch update multiple deposits as staked
func (q *Queries) MarkDepositBatchAsStaked(ctx context.Context, clientVaultID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDepositBatchAsStaked, clientVaultID)
	return err
}

const updateDepositGatewayInfo = `-- name: UpdateDepositGatewayInfo :exec
UPDATE deposit_transactions
SET payment_url = $2,
    gateway_order_id = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateDepositGatewayInfoParams struct {
	ID             uuid.UUID `db:"id"`
	PaymentUrl     *string   `db:"payment_url"`
	GatewayOrderID *string   `db:"gateway_order_id"`
}

// Update after initiating external payment
func (q *Queries) UpdateDepositGatewayInfo(ctx context.Context, arg UpdateDepositGatewayInfoParams) error {
	_, err := q.db.Exec(ctx, updateDepositGatewayInfo, arg.ID, arg.PaymentUrl, arg.GatewayOrderID)
	return err
}
