// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vault.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPendingDepositToVault = `-- name: AddPendingDepositToVault :exec
UPDATE client_vaults
SET pending_deposit_balance = pending_deposit_balance + $2,
    total_shares = total_shares + $3,
    updated_at = now()
WHERE id = $1
`

type AddPendingDepositToVaultParams struct {
	ID                    uuid.UUID      `db:"id"`
	PendingDepositBalance pgtype.Numeric `db:"pending_deposit_balance"`
	TotalShares           pgtype.Numeric `db:"total_shares"`
}

// Add to pending balance and increment total shares
func (q *Queries) AddPendingDepositToVault(ctx context.Context, arg AddPendingDepositToVaultParams) error {
	_, err := q.db.Exec(ctx, addPendingDepositToVault, arg.ID, arg.PendingDepositBalance, arg.TotalShares)
	return err
}

const addSharesToUserVault = `-- name: AddSharesToUserVault :exec
UPDATE end_user_vaults
SET shares = $2,  -- new total shares
    weighted_entry_index = $3,  -- recalculated weighted entry index
    total_deposited = total_deposited + $4,  -- increment deposited amount
    last_deposit_at = now(),
    updated_at = now()
WHERE id = $1
`

type AddSharesToUserVaultParams struct {
	ID                 uuid.UUID      `db:"id"`
	Shares             pgtype.Numeric `db:"shares"`
	WeightedEntryIndex pgtype.Numeric `db:"weighted_entry_index"`
	TotalDeposited     pgtype.Numeric `db:"total_deposited"`
}

// Add shares from a new deposit with weighted entry index update
func (q *Queries) AddSharesToUserVault(ctx context.Context, arg AddSharesToUserVaultParams) error {
	_, err := q.db.Exec(ctx, addSharesToUserVault,
		arg.ID,
		arg.Shares,
		arg.WeightedEntryIndex,
		arg.TotalDeposited,
	)
	return err
}

const burnSharesFromUserVault = `-- name: BurnSharesFromUserVault :exec
UPDATE end_user_vaults
SET shares = shares - $2,  -- shares to burn
    total_withdrawn = total_withdrawn + $3,  -- withdrawal amount
    last_withdrawal_at = now(),
    updated_at = now()
WHERE id = $1
`

type BurnSharesFromUserVaultParams struct {
	ID             uuid.UUID      `db:"id"`
	Shares         pgtype.Numeric `db:"shares"`
	TotalWithdrawn pgtype.Numeric `db:"total_withdrawn"`
}

// Burn shares for withdrawal
func (q *Queries) BurnSharesFromUserVault(ctx context.Context, arg BurnSharesFromUserVaultParams) error {
	_, err := q.db.Exec(ctx, burnSharesFromUserVault, arg.ID, arg.Shares, arg.TotalWithdrawn)
	return err
}

const createClientVault = `-- name: CreateClientVault :one
INSERT INTO client_vaults (
  client_id,
  chain,
  token_address,
  token_symbol,
  current_index,
  total_shares,
  pending_deposit_balance,
  total_staked_balance,
  cumulative_yield
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, is_active, created_at, updated_at
`

type CreateClientVaultParams struct {
	ClientID              uuid.UUID      `db:"client_id"`
	Chain                 string         `db:"chain"`
	TokenAddress          string         `db:"token_address"`
	TokenSymbol           string         `db:"token_symbol"`
	CurrentIndex          pgtype.Numeric `db:"current_index"`
	TotalShares           pgtype.Numeric `db:"total_shares"`
	PendingDepositBalance pgtype.Numeric `db:"pending_deposit_balance"`
	TotalStakedBalance    pgtype.Numeric `db:"total_staked_balance"`
	CumulativeYield       pgtype.Numeric `db:"cumulative_yield"`
}

func (q *Queries) CreateClientVault(ctx context.Context, arg CreateClientVaultParams) (ClientVault, error) {
	row := q.db.QueryRow(ctx, createClientVault,
		arg.ClientID,
		arg.Chain,
		arg.TokenAddress,
		arg.TokenSymbol,
		arg.CurrentIndex,
		arg.TotalShares,
		arg.PendingDepositBalance,
		arg.TotalStakedBalance,
		arg.CumulativeYield,
	)
	var i ClientVault
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEndUserVault = `-- name: CreateEndUserVault :one
INSERT INTO end_user_vaults (
  end_user_id,
  client_id,
  chain,
  token_address,
  token_symbol,
  shares,
  weighted_entry_index,
  total_deposited
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, end_user_id, client_id, chain, token_address, token_symbol, shares, weighted_entry_index, total_deposited, total_withdrawn, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at
`

type CreateEndUserVaultParams struct {
	EndUserID          uuid.UUID      `db:"end_user_id"`
	ClientID           uuid.UUID      `db:"client_id"`
	Chain              string         `db:"chain"`
	TokenAddress       string         `db:"token_address"`
	TokenSymbol        string         `db:"token_symbol"`
	Shares             pgtype.Numeric `db:"shares"`
	WeightedEntryIndex pgtype.Numeric `db:"weighted_entry_index"`
	TotalDeposited     pgtype.Numeric `db:"total_deposited"`
}

func (q *Queries) CreateEndUserVault(ctx context.Context, arg CreateEndUserVaultParams) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, createEndUserVault,
		arg.EndUserID,
		arg.ClientID,
		arg.Chain,
		arg.TokenAddress,
		arg.TokenSymbol,
		arg.Shares,
		arg.WeightedEntryIndex,
		arg.TotalDeposited,
	)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Shares,
		&i.WeightedEntryIndex,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientVault = `-- name: GetClientVault :one


SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, is_active, created_at, updated_at FROM client_vaults
WHERE id = $1 LIMIT 1
`

// ============================================
// VAULT QUERIES (Index-Based Accounting)
// ============================================
// ============================================
// CLIENT VAULT OPERATIONS
// ============================================
func (q *Queries) GetClientVault(ctx context.Context, id uuid.UUID) (ClientVault, error) {
	row := q.db.QueryRow(ctx, getClientVault, id)
	var i ClientVault
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientVaultByToken = `-- name: GetClientVaultByToken :one
SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, is_active, created_at, updated_at FROM client_vaults
WHERE client_id = $1
  AND chain = $2
  AND token_address = $3
LIMIT 1
`

type GetClientVaultByTokenParams struct {
	ClientID     uuid.UUID `db:"client_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

func (q *Queries) GetClientVaultByToken(ctx context.Context, arg GetClientVaultByTokenParams) (ClientVault, error) {
	row := q.db.QueryRow(ctx, getClientVaultByToken, arg.ClientID, arg.Chain, arg.TokenAddress)
	var i ClientVault
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientVaultByTokenForUpdate = `-- name: GetClientVaultByTokenForUpdate :one
SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, is_active, created_at, updated_at FROM client_vaults
WHERE client_id = $1
  AND chain = $2
  AND token_address = $3
FOR UPDATE
LIMIT 1
`

type GetClientVaultByTokenForUpdateParams struct {
	ClientID     uuid.UUID `db:"client_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

// Use in transactions to lock the vault row
func (q *Queries) GetClientVaultByTokenForUpdate(ctx context.Context, arg GetClientVaultByTokenForUpdateParams) (ClientVault, error) {
	row := q.db.QueryRow(ctx, getClientVaultByTokenForUpdate, arg.ClientID, arg.Chain, arg.TokenAddress)
	var i ClientVault
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserVault = `-- name: GetEndUserVault :one

SELECT id, end_user_id, client_id, chain, token_address, token_symbol, shares, weighted_entry_index, total_deposited, total_withdrawn, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE id = $1 LIMIT 1
`

// ============================================
// END-USER VAULT OPERATIONS
// ============================================
func (q *Queries) GetEndUserVault(ctx context.Context, id uuid.UUID) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, getEndUserVault, id)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Shares,
		&i.WeightedEntryIndex,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserVaultByToken = `-- name: GetEndUserVaultByToken :one
SELECT id, end_user_id, client_id, chain, token_address, token_symbol, shares, weighted_entry_index, total_deposited, total_withdrawn, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE end_user_id = $1
  AND chain = $2
  AND token_address = $3
LIMIT 1
`

type GetEndUserVaultByTokenParams struct {
	EndUserID    uuid.UUID `db:"end_user_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

func (q *Queries) GetEndUserVaultByToken(ctx context.Context, arg GetEndUserVaultByTokenParams) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, getEndUserVaultByToken, arg.EndUserID, arg.Chain, arg.TokenAddress)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Shares,
		&i.WeightedEntryIndex,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserVaultByTokenForUpdate = `-- name: GetEndUserVaultByTokenForUpdate :one
SELECT id, end_user_id, client_id, chain, token_address, token_symbol, shares, weighted_entry_index, total_deposited, total_withdrawn, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE end_user_id = $1
  AND chain = $2
  AND token_address = $3
FOR UPDATE
LIMIT 1
`

type GetEndUserVaultByTokenForUpdateParams struct {
	EndUserID    uuid.UUID `db:"end_user_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

// Use in transactions to lock the user vault row
func (q *Queries) GetEndUserVaultByTokenForUpdate(ctx context.Context, arg GetEndUserVaultByTokenForUpdateParams) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, getEndUserVaultByTokenForUpdate, arg.EndUserID, arg.Chain, arg.TokenAddress)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Shares,
		&i.WeightedEntryIndex,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserVaultWithBalance = `-- name: GetEndUserVaultWithBalance :one
SELECT
  euv.id, euv.end_user_id, euv.client_id, euv.chain, euv.token_address, euv.token_symbol, euv.shares, euv.weighted_entry_index, euv.total_deposited, euv.total_withdrawn, euv.last_deposit_at, euv.last_withdrawal_at, euv.is_active, euv.created_at, euv.updated_at,
  cv.current_index,
  cv.token_symbol,
  cv.apy_7d,
  cv.apy_30d,
  cv.total_staked_balance,
  cv.pending_deposit_balance,
  -- Effective balance = shares * current_index / 1e18
  (euv.shares * cv.current_index / 1000000000000000000) AS effective_balance,
  -- Yield earned = effective_balance - total_deposited
  ((euv.shares * cv.current_index / 1000000000000000000) - euv.total_deposited) AS yield_earned
FROM end_user_vaults euv
JOIN client_vaults cv
  ON euv.client_id = cv.client_id
  AND euv.chain = cv.chain
  AND euv.token_address = cv.token_address
WHERE euv.end_user_id = $1
  AND euv.chain = $2
  AND euv.token_address = $3
LIMIT 1
`

type GetEndUserVaultWithBalanceParams struct {
	EndUserID    uuid.UUID `db:"end_user_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

type GetEndUserVaultWithBalanceRow struct {
	ID                    uuid.UUID          `db:"id"`
	EndUserID             uuid.UUID          `db:"end_user_id"`
	ClientID              uuid.UUID          `db:"client_id"`
	Chain                 string             `db:"chain"`
	TokenAddress          string             `db:"token_address"`
	TokenSymbol           string             `db:"token_symbol"`
	Shares                pgtype.Numeric     `db:"shares"`
	WeightedEntryIndex    pgtype.Numeric     `db:"weighted_entry_index"`
	TotalDeposited        pgtype.Numeric     `db:"total_deposited"`
	TotalWithdrawn        pgtype.Numeric     `db:"total_withdrawn"`
	LastDepositAt         pgtype.Timestamptz `db:"last_deposit_at"`
	LastWithdrawalAt      pgtype.Timestamptz `db:"last_withdrawal_at"`
	IsActive              bool               `db:"is_active"`
	CreatedAt             pgtype.Timestamptz `db:"created_at"`
	UpdatedAt             pgtype.Timestamptz `db:"updated_at"`
	CurrentIndex          pgtype.Numeric     `db:"current_index"`
	TokenSymbol_2         string             `db:"token_symbol_2"`
	Apy7d                 pgtype.Numeric     `db:"apy_7d"`
	Apy30d                pgtype.Numeric     `db:"apy_30d"`
	TotalStakedBalance    pgtype.Numeric     `db:"total_staked_balance"`
	PendingDepositBalance pgtype.Numeric     `db:"pending_deposit_balance"`
	EffectiveBalance      int32              `db:"effective_balance"`
	YieldEarned           int32              `db:"yield_earned"`
}

// Get single vault with balance calculation
func (q *Queries) GetEndUserVaultWithBalance(ctx context.Context, arg GetEndUserVaultWithBalanceParams) (GetEndUserVaultWithBalanceRow, error) {
	row := q.db.QueryRow(ctx, getEndUserVaultWithBalance, arg.EndUserID, arg.Chain, arg.TokenAddress)
	var i GetEndUserVaultWithBalanceRow
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Shares,
		&i.WeightedEntryIndex,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentIndex,
		&i.TokenSymbol_2,
		&i.Apy7d,
		&i.Apy30d,
		&i.TotalStakedBalance,
		&i.PendingDepositBalance,
		&i.EffectiveBalance,
		&i.YieldEarned,
	)
	return i, err
}

const getTotalSharesForVault = `-- name: GetTotalSharesForVault :one
SELECT COALESCE(SUM(shares), 0) AS total_user_shares
FROM end_user_vaults
WHERE client_id = $1
  AND chain = $2
  AND token_address = $3
  AND is_active = true
`

type GetTotalSharesForVaultParams struct {
	ClientID     uuid.UUID `db:"client_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

// Verify invariant: sum of user shares == client vault total_shares
func (q *Queries) GetTotalSharesForVault(ctx context.Context, arg GetTotalSharesForVaultParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTotalSharesForVault, arg.ClientID, arg.Chain, arg.TokenAddress)
	var total_user_shares interface{}
	err := row.Scan(&total_user_shares)
	return total_user_shares, err
}

const getVaultSummary = `-- name: GetVaultSummary :one

SELECT
  cv.id,
  cv.chain,
  cv.token_symbol,
  cv.current_index,
  cv.pending_deposit_balance,
  cv.total_staked_balance,
  cv.cumulative_yield,
  cv.apy_7d,
  cv.apy_30d,
  cv.total_shares,
  cv.last_index_update,
  COUNT(DISTINCT euv.end_user_id) AS total_users,
  COALESCE(SUM(euv.total_deposited), 0) AS total_user_deposits,
  COALESCE(SUM(euv.total_withdrawn), 0) AS total_user_withdrawals
FROM client_vaults cv
LEFT JOIN end_user_vaults euv
  ON cv.client_id = euv.client_id
  AND cv.chain = euv.chain
  AND cv.token_address = euv.token_address
  AND euv.is_active = true
WHERE cv.id = $1
GROUP BY cv.id
`

type GetVaultSummaryRow struct {
	ID                    uuid.UUID          `db:"id"`
	Chain                 string             `db:"chain"`
	TokenSymbol           string             `db:"token_symbol"`
	CurrentIndex          pgtype.Numeric     `db:"current_index"`
	PendingDepositBalance pgtype.Numeric     `db:"pending_deposit_balance"`
	TotalStakedBalance    pgtype.Numeric     `db:"total_staked_balance"`
	CumulativeYield       pgtype.Numeric     `db:"cumulative_yield"`
	Apy7d                 pgtype.Numeric     `db:"apy_7d"`
	Apy30d                pgtype.Numeric     `db:"apy_30d"`
	TotalShares           pgtype.Numeric     `db:"total_shares"`
	LastIndexUpdate       pgtype.Timestamptz `db:"last_index_update"`
	TotalUsers            int64              `db:"total_users"`
	TotalUserDeposits     interface{}        `db:"total_user_deposits"`
	TotalUserWithdrawals  interface{}        `db:"total_user_withdrawals"`
}

// ============================================
// VAULT ANALYTICS
// ============================================
// Complete vault summary for a client
func (q *Queries) GetVaultSummary(ctx context.Context, id uuid.UUID) (GetVaultSummaryRow, error) {
	row := q.db.QueryRow(ctx, getVaultSummary, id)
	var i GetVaultSummaryRow
	err := row.Scan(
		&i.ID,
		&i.Chain,
		&i.TokenSymbol,
		&i.CurrentIndex,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.TotalShares,
		&i.LastIndexUpdate,
		&i.TotalUsers,
		&i.TotalUserDeposits,
		&i.TotalUserWithdrawals,
	)
	return i, err
}

const listClientVaults = `-- name: ListClientVaults :many
SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, is_active, created_at, updated_at FROM client_vaults
WHERE client_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListClientVaults(ctx context.Context, clientID uuid.UUID) ([]ClientVault, error) {
	rows, err := q.db.Query(ctx, listClientVaults, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientVault
	for rows.Next() {
		var i ClientVault
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.TotalShares,
			&i.CurrentIndex,
			&i.LastIndexUpdate,
			&i.PendingDepositBalance,
			&i.TotalStakedBalance,
			&i.CumulativeYield,
			&i.Apy7d,
			&i.Apy30d,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientVaultsPendingStake = `-- name: ListClientVaultsPendingStake :many
SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, is_active, created_at, updated_at FROM client_vaults
WHERE pending_deposit_balance >= $1  -- minimum threshold (e.g., 10000)
  AND is_active = true
ORDER BY pending_deposit_balance DESC
`

// Get vaults with pending deposits ready for staking
func (q *Queries) ListClientVaultsPendingStake(ctx context.Context, pendingDepositBalance pgtype.Numeric) ([]ClientVault, error) {
	rows, err := q.db.Query(ctx, listClientVaultsPendingStake, pendingDepositBalance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientVault
	for rows.Next() {
		var i ClientVault
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.TotalShares,
			&i.CurrentIndex,
			&i.LastIndexUpdate,
			&i.PendingDepositBalance,
			&i.TotalStakedBalance,
			&i.CumulativeYield,
			&i.Apy7d,
			&i.Apy30d,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEndUserVaults = `-- name: ListEndUserVaults :many
SELECT id, end_user_id, client_id, chain, token_address, token_symbol, shares, weighted_entry_index, total_deposited, total_withdrawn, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE end_user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListEndUserVaults(ctx context.Context, endUserID uuid.UUID) ([]EndUserVault, error) {
	rows, err := q.db.Query(ctx, listEndUserVaults, endUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EndUserVault
	for rows.Next() {
		var i EndUserVault
		if err := rows.Scan(
			&i.ID,
			&i.EndUserID,
			&i.ClientID,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.Shares,
			&i.WeightedEntryIndex,
			&i.TotalDeposited,
			&i.TotalWithdrawn,
			&i.LastDepositAt,
			&i.LastWithdrawalAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEndUserVaultsWithBalance = `-- name: ListEndUserVaultsWithBalance :many
SELECT
  euv.id, euv.end_user_id, euv.client_id, euv.chain, euv.token_address, euv.token_symbol, euv.shares, euv.weighted_entry_index, euv.total_deposited, euv.total_withdrawn, euv.last_deposit_at, euv.last_withdrawal_at, euv.is_active, euv.created_at, euv.updated_at,
  cv.current_index,
  cv.token_symbol,
  -- Effective balance = shares * current_index / 1e18
  (euv.shares * cv.current_index / 1000000000000000000) AS effective_balance,
  -- Yield earned = effective_balance - total_deposited
  ((euv.shares * cv.current_index / 1000000000000000000) - euv.total_deposited) AS yield_earned
FROM end_user_vaults euv
JOIN client_vaults cv
  ON euv.client_id = cv.client_id
  AND euv.chain = cv.chain
  AND euv.token_address = cv.token_address
WHERE euv.end_user_id = $1
  AND euv.is_active = true
ORDER BY effective_balance DESC
`

type ListEndUserVaultsWithBalanceRow struct {
	ID                 uuid.UUID          `db:"id"`
	EndUserID          uuid.UUID          `db:"end_user_id"`
	ClientID           uuid.UUID          `db:"client_id"`
	Chain              string             `db:"chain"`
	TokenAddress       string             `db:"token_address"`
	TokenSymbol        string             `db:"token_symbol"`
	Shares             pgtype.Numeric     `db:"shares"`
	WeightedEntryIndex pgtype.Numeric     `db:"weighted_entry_index"`
	TotalDeposited     pgtype.Numeric     `db:"total_deposited"`
	TotalWithdrawn     pgtype.Numeric     `db:"total_withdrawn"`
	LastDepositAt      pgtype.Timestamptz `db:"last_deposit_at"`
	LastWithdrawalAt   pgtype.Timestamptz `db:"last_withdrawal_at"`
	IsActive           bool               `db:"is_active"`
	CreatedAt          pgtype.Timestamptz `db:"created_at"`
	UpdatedAt          pgtype.Timestamptz `db:"updated_at"`
	CurrentIndex       pgtype.Numeric     `db:"current_index"`
	TokenSymbol_2      string             `db:"token_symbol_2"`
	EffectiveBalance   int32              `db:"effective_balance"`
	YieldEarned        int32              `db:"yield_earned"`
}

// Get user vaults with effective balance calculation
func (q *Queries) ListEndUserVaultsWithBalance(ctx context.Context, endUserID uuid.UUID) ([]ListEndUserVaultsWithBalanceRow, error) {
	rows, err := q.db.Query(ctx, listEndUserVaultsWithBalance, endUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEndUserVaultsWithBalanceRow
	for rows.Next() {
		var i ListEndUserVaultsWithBalanceRow
		if err := rows.Scan(
			&i.ID,
			&i.EndUserID,
			&i.ClientID,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.Shares,
			&i.WeightedEntryIndex,
			&i.TotalDeposited,
			&i.TotalWithdrawn,
			&i.LastDepositAt,
			&i.LastWithdrawalAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentIndex,
			&i.TokenSymbol_2,
			&i.EffectiveBalance,
			&i.YieldEarned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopUsersByBalance = `-- name: ListTopUsersByBalance :many
SELECT
  euv.end_user_id,
  eu.user_id,
  euv.shares,
  euv.weighted_entry_index,
  euv.total_deposited,
  euv.total_withdrawn,
  (euv.shares * cv.current_index / 1000000000000000000) AS effective_balance,
  ((euv.shares * cv.current_index / 1000000000000000000) - euv.total_deposited) AS yield_earned
FROM end_user_vaults euv
JOIN end_users eu ON euv.end_user_id = eu.id
JOIN client_vaults cv
  ON euv.client_id = cv.client_id
  AND euv.chain = cv.chain
  AND euv.token_address = cv.token_address
WHERE cv.id = $1
  AND euv.is_active = true
  AND euv.shares > 0
ORDER BY effective_balance DESC
LIMIT $2
`

type ListTopUsersByBalanceParams struct {
	ID    uuid.UUID `db:"id"`
	Limit int32     `db:"limit"`
}

type ListTopUsersByBalanceRow struct {
	EndUserID          uuid.UUID      `db:"end_user_id"`
	UserID             string         `db:"user_id"`
	Shares             pgtype.Numeric `db:"shares"`
	WeightedEntryIndex pgtype.Numeric `db:"weighted_entry_index"`
	TotalDeposited     pgtype.Numeric `db:"total_deposited"`
	TotalWithdrawn     pgtype.Numeric `db:"total_withdrawn"`
	EffectiveBalance   int32          `db:"effective_balance"`
	YieldEarned        int32          `db:"yield_earned"`
}

// Get top users by effective balance for a vault
func (q *Queries) ListTopUsersByBalance(ctx context.Context, arg ListTopUsersByBalanceParams) ([]ListTopUsersByBalanceRow, error) {
	rows, err := q.db.Query(ctx, listTopUsersByBalance, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTopUsersByBalanceRow
	for rows.Next() {
		var i ListTopUsersByBalanceRow
		if err := rows.Scan(
			&i.EndUserID,
			&i.UserID,
			&i.Shares,
			&i.WeightedEntryIndex,
			&i.TotalDeposited,
			&i.TotalWithdrawn,
			&i.EffectiveBalance,
			&i.YieldEarned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const movePendingToStaked = `-- name: MovePendingToStaked :exec
UPDATE client_vaults
SET pending_deposit_balance = pending_deposit_balance - $2,
    total_staked_balance = total_staked_balance + $2,
    updated_at = now()
WHERE id = $1
`

type MovePendingToStakedParams struct {
	ID                    uuid.UUID      `db:"id"`
	PendingDepositBalance pgtype.Numeric `db:"pending_deposit_balance"`
}

// Move funds from pending to staked (after deploying to DeFi)
func (q *Queries) MovePendingToStaked(ctx context.Context, arg MovePendingToStakedParams) error {
	_, err := q.db.Exec(ctx, movePendingToStaked, arg.ID, arg.PendingDepositBalance)
	return err
}

const reduceStakedBalance = `-- name: ReduceStakedBalance :exec
UPDATE client_vaults
SET total_staked_balance = total_staked_balance - $2,
    total_shares = total_shares - $3,
    updated_at = now()
WHERE id = $1
`

type ReduceStakedBalanceParams struct {
	ID                 uuid.UUID      `db:"id"`
	TotalStakedBalance pgtype.Numeric `db:"total_staked_balance"`
	TotalShares        pgtype.Numeric `db:"total_shares"`
}

// Reduce staked balance and total shares (for withdrawals)
func (q *Queries) ReduceStakedBalance(ctx context.Context, arg ReduceStakedBalanceParams) error {
	_, err := q.db.Exec(ctx, reduceStakedBalance, arg.ID, arg.TotalStakedBalance, arg.TotalShares)
	return err
}

const updateClientVaultAPY = `-- name: UpdateClientVaultAPY :exec
UPDATE client_vaults
SET apy_7d = $2,
    apy_30d = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateClientVaultAPYParams struct {
	ID     uuid.UUID      `db:"id"`
	Apy7d  pgtype.Numeric `db:"apy_7d"`
	Apy30d pgtype.Numeric `db:"apy_30d"`
}

// Update APY metrics
func (q *Queries) UpdateClientVaultAPY(ctx context.Context, arg UpdateClientVaultAPYParams) error {
	_, err := q.db.Exec(ctx, updateClientVaultAPY, arg.ID, arg.Apy7d, arg.Apy30d)
	return err
}

const updateClientVaultIndex = `-- name: UpdateClientVaultIndex :exec
UPDATE client_vaults
SET current_index = $2,
    cumulative_yield = cumulative_yield + $3,
    total_staked_balance = $4,
    last_index_update = now(),
    updated_at = now()
WHERE id = $1
`

type UpdateClientVaultIndexParams struct {
	ID                 uuid.UUID      `db:"id"`
	CurrentIndex       pgtype.Numeric `db:"current_index"`
	CumulativeYield    pgtype.Numeric `db:"cumulative_yield"`
	TotalStakedBalance pgtype.Numeric `db:"total_staked_balance"`
}

// Update the growth index after yield accrual
func (q *Queries) UpdateClientVaultIndex(ctx context.Context, arg UpdateClientVaultIndexParams) error {
	_, err := q.db.Exec(ctx, updateClientVaultIndex,
		arg.ID,
		arg.CurrentIndex,
		arg.CumulativeYield,
		arg.TotalStakedBalance,
	)
	return err
}
