// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vault.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPendingDepositToVault = `-- name: AddPendingDepositToVault :exec
UPDATE client_vaults
SET pending_deposit_balance = pending_deposit_balance + $2,
    total_shares = total_shares + $3,
    updated_at = now()
WHERE id = $1
`

type AddPendingDepositToVaultParams struct {
	ID                    uuid.UUID      `db:"id"`
	PendingDepositBalance pgtype.Numeric `db:"pending_deposit_balance"`
	TotalShares           pgtype.Numeric `db:"total_shares"`
}

// Add to pending balance and increment total shares
func (q *Queries) AddPendingDepositToVault(ctx context.Context, arg AddPendingDepositToVaultParams) error {
	_, err := q.db.Exec(ctx, addPendingDepositToVault, arg.ID, arg.PendingDepositBalance, arg.TotalShares)
	return err
}

const createClientVault = `-- name: CreateClientVault :one
WITH new_vault AS (
  INSERT INTO client_vaults (
    client_id,
    chain,
    token_address,
    token_symbol,
    current_index,
    total_shares,
    pending_deposit_balance,
    total_staked_balance,
    cumulative_yield
  ) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
  )
  RETURNING id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, strategies, is_active, created_at, updated_at
)
SELECT 
  nv.id, nv.client_id, nv.chain, nv.token_address, nv.token_symbol, nv.total_shares, nv.current_index, nv.last_index_update, nv.pending_deposit_balance, nv.total_staked_balance, nv.cumulative_yield, nv.apy_7d, nv.apy_30d, nv.strategies, nv.is_active, nv.created_at, nv.updated_at,
  pa.privy_wallet_address as custodial_wallet_address
FROM new_vault nv
JOIN client_organizations co ON nv.client_id = co.id
JOIN privy_accounts pa ON co.privy_account_id = pa.id
`

type CreateClientVaultParams struct {
	ClientID              uuid.UUID      `db:"client_id"`
	Chain                 string         `db:"chain"`
	TokenAddress          string         `db:"token_address"`
	TokenSymbol           string         `db:"token_symbol"`
	CurrentIndex          pgtype.Numeric `db:"current_index"`
	TotalShares           pgtype.Numeric `db:"total_shares"`
	PendingDepositBalance pgtype.Numeric `db:"pending_deposit_balance"`
	TotalStakedBalance    pgtype.Numeric `db:"total_staked_balance"`
	CumulativeYield       pgtype.Numeric `db:"cumulative_yield"`
}

type CreateClientVaultRow struct {
	ID                     uuid.UUID          `db:"id"`
	ClientID               uuid.UUID          `db:"client_id"`
	Chain                  string             `db:"chain"`
	TokenAddress           string             `db:"token_address"`
	TokenSymbol            string             `db:"token_symbol"`
	TotalShares            pgtype.Numeric     `db:"total_shares"`
	CurrentIndex           pgtype.Numeric     `db:"current_index"`
	LastIndexUpdate        pgtype.Timestamptz `db:"last_index_update"`
	PendingDepositBalance  pgtype.Numeric     `db:"pending_deposit_balance"`
	TotalStakedBalance     pgtype.Numeric     `db:"total_staked_balance"`
	CumulativeYield        pgtype.Numeric     `db:"cumulative_yield"`
	Apy7d                  pgtype.Numeric     `db:"apy_7d"`
	Apy30d                 pgtype.Numeric     `db:"apy_30d"`
	Strategies             []byte             `db:"strategies"`
	IsActive               bool               `db:"is_active"`
	CreatedAt              pgtype.Timestamptz `db:"created_at"`
	UpdatedAt              pgtype.Timestamptz `db:"updated_at"`
	CustodialWalletAddress string             `db:"custodial_wallet_address"`
}

func (q *Queries) CreateClientVault(ctx context.Context, arg CreateClientVaultParams) (CreateClientVaultRow, error) {
	row := q.db.QueryRow(ctx, createClientVault,
		arg.ClientID,
		arg.Chain,
		arg.TokenAddress,
		arg.TokenSymbol,
		arg.CurrentIndex,
		arg.TotalShares,
		arg.PendingDepositBalance,
		arg.TotalStakedBalance,
		arg.CumulativeYield,
	)
	var i CreateClientVaultRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.Strategies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustodialWalletAddress,
	)
	return i, err
}

const createEndUserVault = `-- name: CreateEndUserVault :one
INSERT INTO end_user_vaults (
  end_user_id,
  client_id,
  total_deposited,
  weighted_entry_index
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, end_user_id, client_id, total_deposited, total_withdrawn, weighted_entry_index, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at
`

type CreateEndUserVaultParams struct {
	EndUserID          uuid.UUID      `db:"end_user_id"`
	ClientID           uuid.UUID      `db:"client_id"`
	TotalDeposited     pgtype.Numeric `db:"total_deposited"`
	WeightedEntryIndex pgtype.Numeric `db:"weighted_entry_index"`
}

// Create vault on first deposit (lazy creation)
func (q *Queries) CreateEndUserVault(ctx context.Context, arg CreateEndUserVaultParams) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, createEndUserVault,
		arg.EndUserID,
		arg.ClientID,
		arg.TotalDeposited,
		arg.WeightedEntryIndex,
	)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.WeightedEntryIndex,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientSummary = `-- name: GetClientSummary :one

SELECT
  co.id,
  co.product_id,
  co.company_name,
  COUNT(DISTINCT euv.end_user_id) AS total_users,
  COALESCE(SUM(euv.total_deposited), 0) AS total_user_deposits,
  COALESCE(SUM(euv.total_withdrawn), 0) AS total_user_withdrawals
FROM client_organizations co
LEFT JOIN end_user_vaults euv
  ON co.id = euv.client_id
  AND euv.is_active = true
WHERE co.id = $1
GROUP BY co.id
`

type GetClientSummaryRow struct {
	ID                   uuid.UUID   `db:"id"`
	ProductID            string      `db:"product_id"`
	CompanyName          string      `db:"company_name"`
	TotalUsers           int64       `db:"total_users"`
	TotalUserDeposits    interface{} `db:"total_user_deposits"`
	TotalUserWithdrawals interface{} `db:"total_user_withdrawals"`
}

// ============================================
// VAULT ANALYTICS (SIMPLIFIED)
// ============================================
// Complete client summary (aggregated across all vaults)
func (q *Queries) GetClientSummary(ctx context.Context, id uuid.UUID) (GetClientSummaryRow, error) {
	row := q.db.QueryRow(ctx, getClientSummary, id)
	var i GetClientSummaryRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.CompanyName,
		&i.TotalUsers,
		&i.TotalUserDeposits,
		&i.TotalUserWithdrawals,
	)
	return i, err
}

const getClientVault = `-- name: GetClientVault :one


SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, strategies, is_active, created_at, updated_at FROM client_vaults
WHERE id = $1 LIMIT 1
`

// ============================================
// VAULT QUERIES (Index-Based Accounting)
// ============================================
// ============================================
// CLIENT VAULT OPERATIONS
// ============================================
func (q *Queries) GetClientVault(ctx context.Context, id uuid.UUID) (ClientVault, error) {
	row := q.db.QueryRow(ctx, getClientVault, id)
	var i ClientVault
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.Strategies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientVaultByToken = `-- name: GetClientVaultByToken :one
SELECT 
  cv.id, cv.client_id, cv.chain, cv.token_address, cv.token_symbol, cv.total_shares, cv.current_index, cv.last_index_update, cv.pending_deposit_balance, cv.total_staked_balance, cv.cumulative_yield, cv.apy_7d, cv.apy_30d, cv.strategies, cv.is_active, cv.created_at, cv.updated_at,
  pa.privy_wallet_address as custodial_wallet_address
FROM client_vaults cv
JOIN client_organizations co ON cv.client_id = co.id
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE cv.client_id = $1
  AND cv.chain = $2
  AND cv.token_address = $3
LIMIT 1
`

type GetClientVaultByTokenParams struct {
	ClientID     uuid.UUID `db:"client_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

type GetClientVaultByTokenRow struct {
	ID                     uuid.UUID          `db:"id"`
	ClientID               uuid.UUID          `db:"client_id"`
	Chain                  string             `db:"chain"`
	TokenAddress           string             `db:"token_address"`
	TokenSymbol            string             `db:"token_symbol"`
	TotalShares            pgtype.Numeric     `db:"total_shares"`
	CurrentIndex           pgtype.Numeric     `db:"current_index"`
	LastIndexUpdate        pgtype.Timestamptz `db:"last_index_update"`
	PendingDepositBalance  pgtype.Numeric     `db:"pending_deposit_balance"`
	TotalStakedBalance     pgtype.Numeric     `db:"total_staked_balance"`
	CumulativeYield        pgtype.Numeric     `db:"cumulative_yield"`
	Apy7d                  pgtype.Numeric     `db:"apy_7d"`
	Apy30d                 pgtype.Numeric     `db:"apy_30d"`
	Strategies             []byte             `db:"strategies"`
	IsActive               bool               `db:"is_active"`
	CreatedAt              pgtype.Timestamptz `db:"created_at"`
	UpdatedAt              pgtype.Timestamptz `db:"updated_at"`
	CustodialWalletAddress string             `db:"custodial_wallet_address"`
}

func (q *Queries) GetClientVaultByToken(ctx context.Context, arg GetClientVaultByTokenParams) (GetClientVaultByTokenRow, error) {
	row := q.db.QueryRow(ctx, getClientVaultByToken, arg.ClientID, arg.Chain, arg.TokenAddress)
	var i GetClientVaultByTokenRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.Strategies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustodialWalletAddress,
	)
	return i, err
}

const getClientVaultByTokenForUpdate = `-- name: GetClientVaultByTokenForUpdate :one
SELECT 
  cv.id, cv.client_id, cv.chain, cv.token_address, cv.token_symbol, cv.total_shares, cv.current_index, cv.last_index_update, cv.pending_deposit_balance, cv.total_staked_balance, cv.cumulative_yield, cv.apy_7d, cv.apy_30d, cv.strategies, cv.is_active, cv.created_at, cv.updated_at,
  pa.privy_wallet_address as custodial_wallet_address
FROM client_vaults cv
JOIN client_organizations co ON cv.client_id = co.id
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE cv.client_id = $1
  AND cv.chain = $2
  AND cv.token_address = $3
FOR UPDATE
LIMIT 1
`

type GetClientVaultByTokenForUpdateParams struct {
	ClientID     uuid.UUID `db:"client_id"`
	Chain        string    `db:"chain"`
	TokenAddress string    `db:"token_address"`
}

type GetClientVaultByTokenForUpdateRow struct {
	ID                     uuid.UUID          `db:"id"`
	ClientID               uuid.UUID          `db:"client_id"`
	Chain                  string             `db:"chain"`
	TokenAddress           string             `db:"token_address"`
	TokenSymbol            string             `db:"token_symbol"`
	TotalShares            pgtype.Numeric     `db:"total_shares"`
	CurrentIndex           pgtype.Numeric     `db:"current_index"`
	LastIndexUpdate        pgtype.Timestamptz `db:"last_index_update"`
	PendingDepositBalance  pgtype.Numeric     `db:"pending_deposit_balance"`
	TotalStakedBalance     pgtype.Numeric     `db:"total_staked_balance"`
	CumulativeYield        pgtype.Numeric     `db:"cumulative_yield"`
	Apy7d                  pgtype.Numeric     `db:"apy_7d"`
	Apy30d                 pgtype.Numeric     `db:"apy_30d"`
	Strategies             []byte             `db:"strategies"`
	IsActive               bool               `db:"is_active"`
	CreatedAt              pgtype.Timestamptz `db:"created_at"`
	UpdatedAt              pgtype.Timestamptz `db:"updated_at"`
	CustodialWalletAddress string             `db:"custodial_wallet_address"`
}

// Use in transactions to lock the vault row
func (q *Queries) GetClientVaultByTokenForUpdate(ctx context.Context, arg GetClientVaultByTokenForUpdateParams) (GetClientVaultByTokenForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getClientVaultByTokenForUpdate, arg.ClientID, arg.Chain, arg.TokenAddress)
	var i GetClientVaultByTokenForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.TotalShares,
		&i.CurrentIndex,
		&i.LastIndexUpdate,
		&i.PendingDepositBalance,
		&i.TotalStakedBalance,
		&i.CumulativeYield,
		&i.Apy7d,
		&i.Apy30d,
		&i.Strategies,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustodialWalletAddress,
	)
	return i, err
}

const getEndUserVault = `-- name: GetEndUserVault :one

SELECT id, end_user_id, client_id, total_deposited, total_withdrawn, weighted_entry_index, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE id = $1 LIMIT 1
`

// ============================================
// END-USER VAULT OPERATIONS (SIMPLIFIED)
// ============================================
// âœ… ONE vault per user per client (no chain/token tracking)
// Backend calculates client_growth_index from all client_vaults
// User sees: total_deposited, current_value, yield
func (q *Queries) GetEndUserVault(ctx context.Context, id uuid.UUID) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, getEndUserVault, id)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.WeightedEntryIndex,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserVaultByClient = `-- name: GetEndUserVaultByClient :one
SELECT id, end_user_id, client_id, total_deposited, total_withdrawn, weighted_entry_index, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE end_user_id = $1
  AND client_id = $2
LIMIT 1
`

type GetEndUserVaultByClientParams struct {
	EndUserID uuid.UUID `db:"end_user_id"`
	ClientID  uuid.UUID `db:"client_id"`
}

// Get user's vault for a specific client
func (q *Queries) GetEndUserVaultByClient(ctx context.Context, arg GetEndUserVaultByClientParams) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, getEndUserVaultByClient, arg.EndUserID, arg.ClientID)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.WeightedEntryIndex,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserVaultByClientForUpdate = `-- name: GetEndUserVaultByClientForUpdate :one
SELECT id, end_user_id, client_id, total_deposited, total_withdrawn, weighted_entry_index, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE end_user_id = $1
  AND client_id = $2
FOR UPDATE
LIMIT 1
`

type GetEndUserVaultByClientForUpdateParams struct {
	EndUserID uuid.UUID `db:"end_user_id"`
	ClientID  uuid.UUID `db:"client_id"`
}

// Use in transactions to lock the user vault row
func (q *Queries) GetEndUserVaultByClientForUpdate(ctx context.Context, arg GetEndUserVaultByClientForUpdateParams) (EndUserVault, error) {
	row := q.db.QueryRow(ctx, getEndUserVaultByClientForUpdate, arg.EndUserID, arg.ClientID)
	var i EndUserVault
	err := row.Scan(
		&i.ID,
		&i.EndUserID,
		&i.ClientID,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.WeightedEntryIndex,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVaultHistoricalIndex = `-- name: GetVaultHistoricalIndex :one
SELECT current_index, last_index_update
FROM client_vaults
WHERE id = $1
  AND last_index_update >= NOW() - INTERVAL '1 day' * $2
ORDER BY last_index_update ASC
LIMIT 1
`

type GetVaultHistoricalIndexParams struct {
	ID       uuid.UUID   `db:"id"`
	DaysBack interface{} `db:"days_back"`
}

type GetVaultHistoricalIndexRow struct {
	CurrentIndex    pgtype.Numeric     `db:"current_index"`
	LastIndexUpdate pgtype.Timestamptz `db:"last_index_update"`
}

// Get historical index for APY calculation
func (q *Queries) GetVaultHistoricalIndex(ctx context.Context, arg GetVaultHistoricalIndexParams) (GetVaultHistoricalIndexRow, error) {
	row := q.db.QueryRow(ctx, getVaultHistoricalIndex, arg.ID, arg.DaysBack)
	var i GetVaultHistoricalIndexRow
	err := row.Scan(&i.CurrentIndex, &i.LastIndexUpdate)
	return i, err
}

const listActiveVaultsForIndexUpdate = `-- name: ListActiveVaultsForIndexUpdate :many
SELECT
  id,
  client_id,
  chain,
  token_symbol,
  current_index,
  total_staked_balance,
  strategies,
  last_index_update
FROM client_vaults
WHERE is_active = true
  AND total_staked_balance > 0
ORDER BY last_index_update ASC
`

type ListActiveVaultsForIndexUpdateRow struct {
	ID                 uuid.UUID          `db:"id"`
	ClientID           uuid.UUID          `db:"client_id"`
	Chain              string             `db:"chain"`
	TokenSymbol        string             `db:"token_symbol"`
	CurrentIndex       pgtype.Numeric     `db:"current_index"`
	TotalStakedBalance pgtype.Numeric     `db:"total_staked_balance"`
	Strategies         []byte             `db:"strategies"`
	LastIndexUpdate    pgtype.Timestamptz `db:"last_index_update"`
}

// Get all active vaults with staked balance for daily index updates
func (q *Queries) ListActiveVaultsForIndexUpdate(ctx context.Context) ([]ListActiveVaultsForIndexUpdateRow, error) {
	rows, err := q.db.Query(ctx, listActiveVaultsForIndexUpdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveVaultsForIndexUpdateRow
	for rows.Next() {
		var i ListActiveVaultsForIndexUpdateRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Chain,
			&i.TokenSymbol,
			&i.CurrentIndex,
			&i.TotalStakedBalance,
			&i.Strategies,
			&i.LastIndexUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientVaults = `-- name: ListClientVaults :many
SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, strategies, is_active, created_at, updated_at FROM client_vaults
WHERE client_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListClientVaults(ctx context.Context, clientID uuid.UUID) ([]ClientVault, error) {
	rows, err := q.db.Query(ctx, listClientVaults, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientVault
	for rows.Next() {
		var i ClientVault
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.TotalShares,
			&i.CurrentIndex,
			&i.LastIndexUpdate,
			&i.PendingDepositBalance,
			&i.TotalStakedBalance,
			&i.CumulativeYield,
			&i.Apy7d,
			&i.Apy30d,
			&i.Strategies,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientVaultsPendingStake = `-- name: ListClientVaultsPendingStake :many
SELECT id, client_id, chain, token_address, token_symbol, total_shares, current_index, last_index_update, pending_deposit_balance, total_staked_balance, cumulative_yield, apy_7d, apy_30d, strategies, is_active, created_at, updated_at FROM client_vaults
WHERE pending_deposit_balance >= $1  -- minimum threshold (e.g., 10000)
  AND is_active = true
ORDER BY pending_deposit_balance DESC
`

// Get vaults with pending deposits ready for staking
func (q *Queries) ListClientVaultsPendingStake(ctx context.Context, pendingDepositBalance pgtype.Numeric) ([]ClientVault, error) {
	rows, err := q.db.Query(ctx, listClientVaultsPendingStake, pendingDepositBalance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientVault
	for rows.Next() {
		var i ClientVault
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.TotalShares,
			&i.CurrentIndex,
			&i.LastIndexUpdate,
			&i.PendingDepositBalance,
			&i.TotalStakedBalance,
			&i.CumulativeYield,
			&i.Apy7d,
			&i.Apy30d,
			&i.Strategies,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEndUserVaults = `-- name: ListEndUserVaults :many
SELECT id, end_user_id, client_id, total_deposited, total_withdrawn, weighted_entry_index, last_deposit_at, last_withdrawal_at, is_active, created_at, updated_at FROM end_user_vaults
WHERE end_user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListEndUserVaults(ctx context.Context, endUserID uuid.UUID) ([]EndUserVault, error) {
	rows, err := q.db.Query(ctx, listEndUserVaults, endUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EndUserVault
	for rows.Next() {
		var i EndUserVault
		if err := rows.Scan(
			&i.ID,
			&i.EndUserID,
			&i.ClientID,
			&i.TotalDeposited,
			&i.TotalWithdrawn,
			&i.WeightedEntryIndex,
			&i.LastDepositAt,
			&i.LastWithdrawalAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopUsersByDeposit = `-- name: ListTopUsersByDeposit :many
SELECT
  euv.end_user_id,
  eu.user_id,
  euv.total_deposited,
  euv.total_withdrawn,
  euv.weighted_entry_index,
  euv.last_deposit_at
FROM end_user_vaults euv
JOIN end_users eu ON euv.end_user_id = eu.id
WHERE euv.client_id = $1
  AND euv.is_active = true
  AND euv.total_deposited > 0
ORDER BY euv.total_deposited DESC
LIMIT $2
`

type ListTopUsersByDepositParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Limit    int32     `db:"limit"`
}

type ListTopUsersByDepositRow struct {
	EndUserID          uuid.UUID          `db:"end_user_id"`
	UserID             string             `db:"user_id"`
	TotalDeposited     pgtype.Numeric     `db:"total_deposited"`
	TotalWithdrawn     pgtype.Numeric     `db:"total_withdrawn"`
	WeightedEntryIndex pgtype.Numeric     `db:"weighted_entry_index"`
	LastDepositAt      pgtype.Timestamptz `db:"last_deposit_at"`
}

// Get top users by total deposited for a client
func (q *Queries) ListTopUsersByDeposit(ctx context.Context, arg ListTopUsersByDepositParams) ([]ListTopUsersByDepositRow, error) {
	rows, err := q.db.Query(ctx, listTopUsersByDeposit, arg.ClientID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTopUsersByDepositRow
	for rows.Next() {
		var i ListTopUsersByDepositRow
		if err := rows.Scan(
			&i.EndUserID,
			&i.UserID,
			&i.TotalDeposited,
			&i.TotalWithdrawn,
			&i.WeightedEntryIndex,
			&i.LastDepositAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const movePendingToStaked = `-- name: MovePendingToStaked :exec
UPDATE client_vaults
SET pending_deposit_balance = pending_deposit_balance - $2,
    total_staked_balance = total_staked_balance + $2,
    updated_at = now()
WHERE id = $1
`

type MovePendingToStakedParams struct {
	ID                    uuid.UUID      `db:"id"`
	PendingDepositBalance pgtype.Numeric `db:"pending_deposit_balance"`
}

// Move funds from pending to staked (after deploying to DeFi)
func (q *Queries) MovePendingToStaked(ctx context.Context, arg MovePendingToStakedParams) error {
	_, err := q.db.Exec(ctx, movePendingToStaked, arg.ID, arg.PendingDepositBalance)
	return err
}

const reduceStakedBalance = `-- name: ReduceStakedBalance :exec
UPDATE client_vaults
SET total_staked_balance = total_staked_balance - $2,
    total_shares = total_shares - $3,
    updated_at = now()
WHERE id = $1
`

type ReduceStakedBalanceParams struct {
	ID                 uuid.UUID      `db:"id"`
	TotalStakedBalance pgtype.Numeric `db:"total_staked_balance"`
	TotalShares        pgtype.Numeric `db:"total_shares"`
}

// Reduce staked balance and total shares (for withdrawals)
func (q *Queries) ReduceStakedBalance(ctx context.Context, arg ReduceStakedBalanceParams) error {
	_, err := q.db.Exec(ctx, reduceStakedBalance, arg.ID, arg.TotalStakedBalance, arg.TotalShares)
	return err
}

const updateClientVaultAPY = `-- name: UpdateClientVaultAPY :exec
UPDATE client_vaults
SET apy_7d = $2,
    apy_30d = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateClientVaultAPYParams struct {
	ID     uuid.UUID      `db:"id"`
	Apy7d  pgtype.Numeric `db:"apy_7d"`
	Apy30d pgtype.Numeric `db:"apy_30d"`
}

// Update APY metrics
func (q *Queries) UpdateClientVaultAPY(ctx context.Context, arg UpdateClientVaultAPYParams) error {
	_, err := q.db.Exec(ctx, updateClientVaultAPY, arg.ID, arg.Apy7d, arg.Apy30d)
	return err
}

const updateClientVaultIndex = `-- name: UpdateClientVaultIndex :exec
UPDATE client_vaults
SET current_index = $2,
    cumulative_yield = cumulative_yield + $3,
    total_staked_balance = $4,
    last_index_update = now(),
    updated_at = now()
WHERE id = $1
`

type UpdateClientVaultIndexParams struct {
	ID                 uuid.UUID      `db:"id"`
	CurrentIndex       pgtype.Numeric `db:"current_index"`
	CumulativeYield    pgtype.Numeric `db:"cumulative_yield"`
	TotalStakedBalance pgtype.Numeric `db:"total_staked_balance"`
}

// Update the growth index after yield accrual
func (q *Queries) UpdateClientVaultIndex(ctx context.Context, arg UpdateClientVaultIndexParams) error {
	_, err := q.db.Exec(ctx, updateClientVaultIndex,
		arg.ID,
		arg.CurrentIndex,
		arg.CumulativeYield,
		arg.TotalStakedBalance,
	)
	return err
}

const updateEndUserVaultDeposit = `-- name: UpdateEndUserVaultDeposit :exec
UPDATE end_user_vaults
SET total_deposited = total_deposited + $2,  -- Add deposit amount
    weighted_entry_index = $3,  -- Recalculate weighted entry index
    last_deposit_at = now(),
    updated_at = now()
WHERE id = $1
`

type UpdateEndUserVaultDepositParams struct {
	ID                 uuid.UUID      `db:"id"`
	TotalDeposited     pgtype.Numeric `db:"total_deposited"`
	WeightedEntryIndex pgtype.Numeric `db:"weighted_entry_index"`
}

// Update vault on deposit (DCA support with weighted entry index)
func (q *Queries) UpdateEndUserVaultDeposit(ctx context.Context, arg UpdateEndUserVaultDepositParams) error {
	_, err := q.db.Exec(ctx, updateEndUserVaultDeposit, arg.ID, arg.TotalDeposited, arg.WeightedEntryIndex)
	return err
}

const updateEndUserVaultWithdrawal = `-- name: UpdateEndUserVaultWithdrawal :exec
UPDATE end_user_vaults
SET total_withdrawn = total_withdrawn + $2,  -- Add withdrawal amount
    last_withdrawal_at = now(),
    updated_at = now()
WHERE id = $1
`

type UpdateEndUserVaultWithdrawalParams struct {
	ID             uuid.UUID      `db:"id"`
	TotalWithdrawn pgtype.Numeric `db:"total_withdrawn"`
}

// Update vault on withdrawal
func (q *Queries) UpdateEndUserVaultWithdrawal(ctx context.Context, arg UpdateEndUserVaultWithdrawalParams) error {
	_, err := q.db.Exec(ctx, updateEndUserVaultWithdrawal, arg.ID, arg.TotalWithdrawn)
	return err
}

const updateTotalStakedBalance = `-- name: UpdateTotalStakedBalance :exec
UPDATE client_vaults
SET total_staked_balance = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateTotalStakedBalanceParams struct {
	ID                 uuid.UUID      `db:"id"`
	TotalStakedBalance pgtype.Numeric `db:"total_staked_balance"`
}

// Update total staked balance (after deposit/withdrawal)
func (q *Queries) UpdateTotalStakedBalance(ctx context.Context, arg UpdateTotalStakedBalanceParams) error {
	_, err := q.db.Exec(ctx, updateTotalStakedBalance, arg.ID, arg.TotalStakedBalance)
	return err
}
