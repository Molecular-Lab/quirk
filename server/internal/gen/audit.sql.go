// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: audit.sql

package gen

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
  client_id,
  user_id,
  actor_type,
  action,
  resource_type,
  resource_id,
  description,
  metadata,
  ip_address,
  user_agent
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at
`

type CreateAuditLogParams struct {
	ClientID     pgtype.UUID `db:"client_id"`
	UserID       *string     `db:"user_id"`
	ActorType    string      `db:"actor_type"`
	Action       string      `db:"action"`
	ResourceType *string     `db:"resource_type"`
	ResourceID   *string     `db:"resource_id"`
	Description  *string     `db:"description"`
	Metadata     []byte      `db:"metadata"`
	IpAddress    *netip.Addr `db:"ip_address"`
	UserAgent    *string     `db:"user_agent"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.ClientID,
		arg.UserID,
		arg.ActorType,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Description,
		arg.Metadata,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.ActorType,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Description,
		&i.Metadata,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldAuditLogs = `-- name: DeleteOldAuditLogs :exec
DELETE FROM audit_logs
WHERE created_at < $1
`

// Delete audit logs older than specified date (for cleanup)
func (q *Queries) DeleteOldAuditLogs(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldAuditLogs, createdAt)
	return err
}

const getActionFrequency = `-- name: GetActionFrequency :many

SELECT
  action,
  COUNT(*) AS count,
  MIN(created_at) AS first_occurrence,
  MAX(created_at) AS last_occurrence
FROM audit_logs
WHERE client_id = $1
  AND created_at >= $2
  AND created_at <= $3
GROUP BY action
ORDER BY count DESC
`

type GetActionFrequencyParams struct {
	ClientID    pgtype.UUID        `db:"client_id"`
	CreatedAt   pgtype.Timestamptz `db:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `db:"created_at_2"`
}

type GetActionFrequencyRow struct {
	Action          string      `db:"action"`
	Count           int64       `db:"count"`
	FirstOccurrence interface{} `db:"first_occurrence"`
	LastOccurrence  interface{} `db:"last_occurrence"`
}

// ============================================
// AUDIT ANALYTICS
// ============================================
// Get frequency of actions
func (q *Queries) GetActionFrequency(ctx context.Context, arg GetActionFrequencyParams) ([]GetActionFrequencyRow, error) {
	rows, err := q.db.Query(ctx, getActionFrequency, arg.ClientID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActionFrequencyRow
	for rows.Next() {
		var i GetActionFrequencyRow
		if err := rows.Scan(
			&i.Action,
			&i.Count,
			&i.FirstOccurrence,
			&i.LastOccurrence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLog = `-- name: GetAuditLog :one

SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE id = $1 LIMIT 1
`

// ============================================
// AUDIT LOG QUERIES
// ============================================
func (q *Queries) GetAuditLog(ctx context.Context, id uuid.UUID) (AuditLog, error) {
	row := q.db.QueryRow(ctx, getAuditLog, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.ActorType,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Description,
		&i.Metadata,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const getResourceActivity = `-- name: GetResourceActivity :many
SELECT
  action,
  actor_type,
  user_id,
  description,
  metadata,
  created_at
FROM audit_logs
WHERE resource_type = $1
  AND resource_id = $2
ORDER BY created_at DESC
LIMIT $3
`

type GetResourceActivityParams struct {
	ResourceType *string `db:"resource_type"`
	ResourceID   *string `db:"resource_id"`
	Limit        int32   `db:"limit"`
}

type GetResourceActivityRow struct {
	Action      string             `db:"action"`
	ActorType   string             `db:"actor_type"`
	UserID      *string            `db:"user_id"`
	Description *string            `db:"description"`
	Metadata    []byte             `db:"metadata"`
	CreatedAt   pgtype.Timestamptz `db:"created_at"`
}

// Get activity for a specific resource
func (q *Queries) GetResourceActivity(ctx context.Context, arg GetResourceActivityParams) ([]GetResourceActivityRow, error) {
	rows, err := q.db.Query(ctx, getResourceActivity, arg.ResourceType, arg.ResourceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceActivityRow
	for rows.Next() {
		var i GetResourceActivityRow
		if err := rows.Scan(
			&i.Action,
			&i.ActorType,
			&i.UserID,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivity = `-- name: GetUserActivity :many
SELECT
  user_id,
  actor_type,
  COUNT(*) AS total_actions,
  COUNT(DISTINCT action) AS distinct_actions,
  MIN(created_at) AS first_activity,
  MAX(created_at) AS last_activity
FROM audit_logs
WHERE client_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND user_id IS NOT NULL
GROUP BY user_id, actor_type
ORDER BY total_actions DESC
LIMIT $4
`

type GetUserActivityParams struct {
	ClientID    pgtype.UUID        `db:"client_id"`
	CreatedAt   pgtype.Timestamptz `db:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `db:"created_at_2"`
	Limit       int32              `db:"limit"`
}

type GetUserActivityRow struct {
	UserID          *string     `db:"user_id"`
	ActorType       string      `db:"actor_type"`
	TotalActions    int64       `db:"total_actions"`
	DistinctActions int64       `db:"distinct_actions"`
	FirstActivity   interface{} `db:"first_activity"`
	LastActivity    interface{} `db:"last_activity"`
}

// Get user activity summary
func (q *Queries) GetUserActivity(ctx context.Context, arg GetUserActivityParams) ([]GetUserActivityRow, error) {
	rows, err := q.db.Query(ctx, getUserActivity,
		arg.ClientID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserActivityRow
	for rows.Next() {
		var i GetUserActivityRow
		if err := rows.Scan(
			&i.UserID,
			&i.ActorType,
			&i.TotalActions,
			&i.DistinctActions,
			&i.FirstActivity,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAuditLogsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByAction = `-- name: ListAuditLogsByAction :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE action = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByActionParams struct {
	Action string `db:"action"`
	Limit  int32  `db:"limit"`
	Offset int32  `db:"offset"`
}

func (q *Queries) ListAuditLogsByAction(ctx context.Context, arg ListAuditLogsByActionParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByClient = `-- name: ListAuditLogsByClient :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByClientParams struct {
	ClientID pgtype.UUID `db:"client_id"`
	Limit    int32       `db:"limit"`
	Offset   int32       `db:"offset"`
}

func (q *Queries) ListAuditLogsByClient(ctx context.Context, arg ListAuditLogsByClientParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByClient, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByClientAndAction = `-- name: ListAuditLogsByClientAndAction :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE client_id = $1
  AND action = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByClientAndActionParams struct {
	ClientID pgtype.UUID `db:"client_id"`
	Action   string      `db:"action"`
	Limit    int32       `db:"limit"`
	Offset   int32       `db:"offset"`
}

func (q *Queries) ListAuditLogsByClientAndAction(ctx context.Context, arg ListAuditLogsByClientAndActionParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByClientAndAction,
		arg.ClientID,
		arg.Action,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByClientAndDateRange = `-- name: ListAuditLogsByClientAndDateRange :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE client_id = $1
  AND created_at >= $2
  AND created_at <= $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListAuditLogsByClientAndDateRangeParams struct {
	ClientID    pgtype.UUID        `db:"client_id"`
	CreatedAt   pgtype.Timestamptz `db:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `db:"created_at_2"`
	Limit       int32              `db:"limit"`
	Offset      int32              `db:"offset"`
}

func (q *Queries) ListAuditLogsByClientAndDateRange(ctx context.Context, arg ListAuditLogsByClientAndDateRangeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByClientAndDateRange,
		arg.ClientID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByDateRange = `-- name: ListAuditLogsByDateRange :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE created_at >= $1
  AND created_at <= $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `db:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `db:"created_at_2"`
	Limit       int32              `db:"limit"`
	Offset      int32              `db:"offset"`
}

func (q *Queries) ListAuditLogsByDateRange(ctx context.Context, arg ListAuditLogsByDateRangeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByResource = `-- name: ListAuditLogsByResource :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE resource_type = $1
  AND resource_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByResourceParams struct {
	ResourceType *string `db:"resource_type"`
	ResourceID   *string `db:"resource_id"`
	Limit        int32   `db:"limit"`
	Offset       int32   `db:"offset"`
}

func (q *Queries) ListAuditLogsByResource(ctx context.Context, arg ListAuditLogsByResourceParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByResource,
		arg.ResourceType,
		arg.ResourceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByUser = `-- name: ListAuditLogsByUser :many
SELECT id, client_id, user_id, actor_type, action, resource_type, resource_id, description, metadata, ip_address, user_agent, created_at FROM audit_logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByUserParams struct {
	UserID *string `db:"user_id"`
	Limit  int32   `db:"limit"`
	Offset int32   `db:"offset"`
}

func (q *Queries) ListAuditLogsByUser(ctx context.Context, arg ListAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
