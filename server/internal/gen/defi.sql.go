// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: defi.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateProtocol = `-- name: ActivateProtocol :exec
UPDATE supported_defi_protocols
SET is_active = true,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) ActivateProtocol(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateProtocol, id)
	return err
}

const createAllocation = `-- name: CreateAllocation :one
INSERT INTO defi_allocations (
  client_id,
  client_vault_id,
  protocol_id,
  category,
  chain,
  token_address,
  token_symbol,
  balance,
  percentage_allocation,
  apy,
  tx_hash,
  status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, client_id, client_vault_id, protocol_id, category, chain, token_address, token_symbol, balance, percentage_allocation, apy, yield_earned, tx_hash, status, deployed_at, last_rebalance_at, withdrawn_at, created_at, updated_at
`

type CreateAllocationParams struct {
	ClientID             uuid.UUID      `db:"client_id"`
	ClientVaultID        uuid.UUID      `db:"client_vault_id"`
	ProtocolID           uuid.UUID      `db:"protocol_id"`
	Category             string         `db:"category"`
	Chain                string         `db:"chain"`
	TokenAddress         string         `db:"token_address"`
	TokenSymbol          string         `db:"token_symbol"`
	Balance              pgtype.Numeric `db:"balance"`
	PercentageAllocation pgtype.Numeric `db:"percentage_allocation"`
	Apy                  pgtype.Numeric `db:"apy"`
	TxHash               *string        `db:"tx_hash"`
	Status               string         `db:"status"`
}

func (q *Queries) CreateAllocation(ctx context.Context, arg CreateAllocationParams) (DefiAllocation, error) {
	row := q.db.QueryRow(ctx, createAllocation,
		arg.ClientID,
		arg.ClientVaultID,
		arg.ProtocolID,
		arg.Category,
		arg.Chain,
		arg.TokenAddress,
		arg.TokenSymbol,
		arg.Balance,
		arg.PercentageAllocation,
		arg.Apy,
		arg.TxHash,
		arg.Status,
	)
	var i DefiAllocation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientVaultID,
		&i.ProtocolID,
		&i.Category,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Balance,
		&i.PercentageAllocation,
		&i.Apy,
		&i.YieldEarned,
		&i.TxHash,
		&i.Status,
		&i.DeployedAt,
		&i.LastRebalanceAt,
		&i.WithdrawnAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProtocol = `-- name: CreateProtocol :one
INSERT INTO supported_defi_protocols (
  name,
  chain,
  address_book,
  category,
  risk_level,
  is_active
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at
`

type CreateProtocolParams struct {
	Name        string `db:"name"`
	Chain       string `db:"chain"`
	AddressBook []byte `db:"address_book"`
	Category    string `db:"category"`
	RiskLevel   string `db:"risk_level"`
	IsActive    bool   `db:"is_active"`
}

func (q *Queries) CreateProtocol(ctx context.Context, arg CreateProtocolParams) (SupportedDefiProtocol, error) {
	row := q.db.QueryRow(ctx, createProtocol,
		arg.Name,
		arg.Chain,
		arg.AddressBook,
		arg.Category,
		arg.RiskLevel,
		arg.IsActive,
	)
	var i SupportedDefiProtocol
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Chain,
		&i.AddressBook,
		&i.Category,
		&i.RiskLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateProtocol = `-- name: DeactivateProtocol :exec
UPDATE supported_defi_protocols
SET is_active = false,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) DeactivateProtocol(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateProtocol, id)
	return err
}

const decreaseAllocationBalance = `-- name: DecreaseAllocationBalance :exec
UPDATE defi_allocations
SET balance = balance - $2,
    last_rebalance_at = now(),
    updated_at = now()
WHERE id = $1
`

type DecreaseAllocationBalanceParams struct {
	ID      uuid.UUID      `db:"id"`
	Balance pgtype.Numeric `db:"balance"`
}

func (q *Queries) DecreaseAllocationBalance(ctx context.Context, arg DecreaseAllocationBalanceParams) error {
	_, err := q.db.Exec(ctx, decreaseAllocationBalance, arg.ID, arg.Balance)
	return err
}

const deleteAllocation = `-- name: DeleteAllocation :exec
DELETE FROM defi_allocations
WHERE id = $1
`

func (q *Queries) DeleteAllocation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllocation, id)
	return err
}

const deleteProtocol = `-- name: DeleteProtocol :exec
DELETE FROM supported_defi_protocols
WHERE id = $1
`

func (q *Queries) DeleteProtocol(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProtocol, id)
	return err
}

const getAllocation = `-- name: GetAllocation :one

SELECT id, client_id, client_vault_id, protocol_id, category, chain, token_address, token_symbol, balance, percentage_allocation, apy, yield_earned, tx_hash, status, deployed_at, last_rebalance_at, withdrawn_at, created_at, updated_at FROM defi_allocations
WHERE id = $1 LIMIT 1
`

// ============================================
// DEFI ALLOCATION QUERIES
// ============================================
func (q *Queries) GetAllocation(ctx context.Context, id uuid.UUID) (DefiAllocation, error) {
	row := q.db.QueryRow(ctx, getAllocation, id)
	var i DefiAllocation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientVaultID,
		&i.ProtocolID,
		&i.Category,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Balance,
		&i.PercentageAllocation,
		&i.Apy,
		&i.YieldEarned,
		&i.TxHash,
		&i.Status,
		&i.DeployedAt,
		&i.LastRebalanceAt,
		&i.WithdrawnAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllocationByVaultAndProtocol = `-- name: GetAllocationByVaultAndProtocol :one
SELECT id, client_id, client_vault_id, protocol_id, category, chain, token_address, token_symbol, balance, percentage_allocation, apy, yield_earned, tx_hash, status, deployed_at, last_rebalance_at, withdrawn_at, created_at, updated_at FROM defi_allocations
WHERE client_vault_id = $1
  AND protocol_id = $2
LIMIT 1
`

type GetAllocationByVaultAndProtocolParams struct {
	ClientVaultID uuid.UUID `db:"client_vault_id"`
	ProtocolID    uuid.UUID `db:"protocol_id"`
}

func (q *Queries) GetAllocationByVaultAndProtocol(ctx context.Context, arg GetAllocationByVaultAndProtocolParams) (DefiAllocation, error) {
	row := q.db.QueryRow(ctx, getAllocationByVaultAndProtocol, arg.ClientVaultID, arg.ProtocolID)
	var i DefiAllocation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientVaultID,
		&i.ProtocolID,
		&i.Category,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Balance,
		&i.PercentageAllocation,
		&i.Apy,
		&i.YieldEarned,
		&i.TxHash,
		&i.Status,
		&i.DeployedAt,
		&i.LastRebalanceAt,
		&i.WithdrawnAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllocationForUpdate = `-- name: GetAllocationForUpdate :one
SELECT id, client_id, client_vault_id, protocol_id, category, chain, token_address, token_symbol, balance, percentage_allocation, apy, yield_earned, tx_hash, status, deployed_at, last_rebalance_at, withdrawn_at, created_at, updated_at FROM defi_allocations
WHERE id = $1
FOR UPDATE
LIMIT 1
`

// Use in transactions to lock the allocation row
func (q *Queries) GetAllocationForUpdate(ctx context.Context, id uuid.UUID) (DefiAllocation, error) {
	row := q.db.QueryRow(ctx, getAllocationForUpdate, id)
	var i DefiAllocation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientVaultID,
		&i.ProtocolID,
		&i.Category,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Balance,
		&i.PercentageAllocation,
		&i.Apy,
		&i.YieldEarned,
		&i.TxHash,
		&i.Status,
		&i.DeployedAt,
		&i.LastRebalanceAt,
		&i.WithdrawnAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllocationSummary = `-- name: GetAllocationSummary :one

SELECT
  COUNT(DISTINCT da.protocol_id) AS total_protocols,
  COUNT(DISTINCT da.category) AS total_categories,
  COALESCE(SUM(da.balance), 0) AS total_allocated,
  COALESCE(SUM(da.yield_earned), 0) AS total_yield_earned,
  COALESCE(AVG(da.apy), 0) AS avg_apy
FROM defi_allocations da
WHERE da.client_vault_id = $1
  AND da.status = 'active'
`

type GetAllocationSummaryRow struct {
	TotalProtocols   int64       `db:"total_protocols"`
	TotalCategories  int64       `db:"total_categories"`
	TotalAllocated   interface{} `db:"total_allocated"`
	TotalYieldEarned interface{} `db:"total_yield_earned"`
	AvgApy           interface{} `db:"avg_apy"`
}

// ============================================
// DEFI ANALYTICS
// ============================================
// Summary of all allocations for a vault
func (q *Queries) GetAllocationSummary(ctx context.Context, clientVaultID uuid.UUID) (GetAllocationSummaryRow, error) {
	row := q.db.QueryRow(ctx, getAllocationSummary, clientVaultID)
	var i GetAllocationSummaryRow
	err := row.Scan(
		&i.TotalProtocols,
		&i.TotalCategories,
		&i.TotalAllocated,
		&i.TotalYieldEarned,
		&i.AvgApy,
	)
	return i, err
}

const getCategoryAllocationBreakdown = `-- name: GetCategoryAllocationBreakdown :many
SELECT
  da.category,
  COUNT(DISTINCT da.protocol_id) AS num_protocols,
  COALESCE(SUM(da.balance), 0) AS total_balance,
  COALESCE(AVG(da.apy), 0) AS avg_apy,
  COALESCE(SUM(da.yield_earned), 0) AS total_yield
FROM defi_allocations da
WHERE da.client_vault_id = $1
  AND da.status = 'active'
GROUP BY da.category
ORDER BY total_balance DESC
`

type GetCategoryAllocationBreakdownRow struct {
	Category     string      `db:"category"`
	NumProtocols int64       `db:"num_protocols"`
	TotalBalance interface{} `db:"total_balance"`
	AvgApy       interface{} `db:"avg_apy"`
	TotalYield   interface{} `db:"total_yield"`
}

// Allocation breakdown by category
func (q *Queries) GetCategoryAllocationBreakdown(ctx context.Context, clientVaultID uuid.UUID) ([]GetCategoryAllocationBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getCategoryAllocationBreakdown, clientVaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoryAllocationBreakdownRow
	for rows.Next() {
		var i GetCategoryAllocationBreakdownRow
		if err := rows.Scan(
			&i.Category,
			&i.NumProtocols,
			&i.TotalBalance,
			&i.AvgApy,
			&i.TotalYield,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProtocol = `-- name: GetProtocol :one

SELECT id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at FROM supported_defi_protocols
WHERE id = $1 LIMIT 1
`

// ============================================
// DEFI PROTOCOL QUERIES
// ============================================
func (q *Queries) GetProtocol(ctx context.Context, id uuid.UUID) (SupportedDefiProtocol, error) {
	row := q.db.QueryRow(ctx, getProtocol, id)
	var i SupportedDefiProtocol
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Chain,
		&i.AddressBook,
		&i.Category,
		&i.RiskLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProtocolByName = `-- name: GetProtocolByName :one
SELECT id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at FROM supported_defi_protocols
WHERE name = $1
  AND chain = $2
LIMIT 1
`

type GetProtocolByNameParams struct {
	Name  string `db:"name"`
	Chain string `db:"chain"`
}

func (q *Queries) GetProtocolByName(ctx context.Context, arg GetProtocolByNameParams) (SupportedDefiProtocol, error) {
	row := q.db.QueryRow(ctx, getProtocolByName, arg.Name, arg.Chain)
	var i SupportedDefiProtocol
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Chain,
		&i.AddressBook,
		&i.Category,
		&i.RiskLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProtocolPerformance = `-- name: GetProtocolPerformance :many
SELECT
  sdp.name AS protocol_name,
  sdp.category,
  da.chain,
  da.token_symbol,
  da.balance,
  da.yield_earned,
  da.apy,
  da.deployed_at,
  da.last_rebalance_at,
  -- Calculate total return percentage
  CASE
    WHEN da.balance > 0 THEN (da.yield_earned::numeric / da.balance::numeric * 100)
    ELSE 0
  END AS total_return_percent
FROM defi_allocations da
JOIN supported_defi_protocols sdp ON da.protocol_id = sdp.id
WHERE da.client_id = $1
  AND da.status = 'active'
ORDER BY da.yield_earned DESC
`

type GetProtocolPerformanceRow struct {
	ProtocolName       string             `db:"protocol_name"`
	Category           string             `db:"category"`
	Chain              string             `db:"chain"`
	TokenSymbol        string             `db:"token_symbol"`
	Balance            pgtype.Numeric     `db:"balance"`
	YieldEarned        pgtype.Numeric     `db:"yield_earned"`
	Apy                pgtype.Numeric     `db:"apy"`
	DeployedAt         pgtype.Timestamptz `db:"deployed_at"`
	LastRebalanceAt    pgtype.Timestamptz `db:"last_rebalance_at"`
	TotalReturnPercent int32              `db:"total_return_percent"`
}

// Performance metrics per protocol
func (q *Queries) GetProtocolPerformance(ctx context.Context, clientID uuid.UUID) ([]GetProtocolPerformanceRow, error) {
	rows, err := q.db.Query(ctx, getProtocolPerformance, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProtocolPerformanceRow
	for rows.Next() {
		var i GetProtocolPerformanceRow
		if err := rows.Scan(
			&i.ProtocolName,
			&i.Category,
			&i.Chain,
			&i.TokenSymbol,
			&i.Balance,
			&i.YieldEarned,
			&i.Apy,
			&i.DeployedAt,
			&i.LastRebalanceAt,
			&i.TotalReturnPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalAllocatedByClient = `-- name: GetTotalAllocatedByClient :one
SELECT
  COALESCE(SUM(balance), 0) AS total_deployed,
  COALESCE(SUM(yield_earned), 0) AS total_yield,
  COALESCE(AVG(apy), 0) AS weighted_avg_apy
FROM defi_allocations
WHERE client_id = $1
  AND status = 'active'
`

type GetTotalAllocatedByClientRow struct {
	TotalDeployed  interface{} `db:"total_deployed"`
	TotalYield     interface{} `db:"total_yield"`
	WeightedAvgApy interface{} `db:"weighted_avg_apy"`
}

// Total allocated across all vaults for a client
func (q *Queries) GetTotalAllocatedByClient(ctx context.Context, clientID uuid.UUID) (GetTotalAllocatedByClientRow, error) {
	row := q.db.QueryRow(ctx, getTotalAllocatedByClient, clientID)
	var i GetTotalAllocatedByClientRow
	err := row.Scan(&i.TotalDeployed, &i.TotalYield, &i.WeightedAvgApy)
	return i, err
}

const increaseAllocationBalance = `-- name: IncreaseAllocationBalance :exec
UPDATE defi_allocations
SET balance = balance + $2,
    last_rebalance_at = now(),
    updated_at = now()
WHERE id = $1
`

type IncreaseAllocationBalanceParams struct {
	ID      uuid.UUID      `db:"id"`
	Balance pgtype.Numeric `db:"balance"`
}

func (q *Queries) IncreaseAllocationBalance(ctx context.Context, arg IncreaseAllocationBalanceParams) error {
	_, err := q.db.Exec(ctx, increaseAllocationBalance, arg.ID, arg.Balance)
	return err
}

const listActiveAllocations = `-- name: ListActiveAllocations :many
SELECT
  da.id, da.client_id, da.client_vault_id, da.protocol_id, da.category, da.chain, da.token_address, da.token_symbol, da.balance, da.percentage_allocation, da.apy, da.yield_earned, da.tx_hash, da.status, da.deployed_at, da.last_rebalance_at, da.withdrawn_at, da.created_at, da.updated_at,
  sdp.name AS protocol_name,
  sdp.category AS protocol_category,
  sdp.risk_level AS protocol_risk_level
FROM defi_allocations da
JOIN supported_defi_protocols sdp ON da.protocol_id = sdp.id
WHERE da.client_id = $1
  AND da.status = 'active'
ORDER BY da.balance DESC
`

type ListActiveAllocationsRow struct {
	ID                   uuid.UUID          `db:"id"`
	ClientID             uuid.UUID          `db:"client_id"`
	ClientVaultID        uuid.UUID          `db:"client_vault_id"`
	ProtocolID           uuid.UUID          `db:"protocol_id"`
	Category             string             `db:"category"`
	Chain                string             `db:"chain"`
	TokenAddress         string             `db:"token_address"`
	TokenSymbol          string             `db:"token_symbol"`
	Balance              pgtype.Numeric     `db:"balance"`
	PercentageAllocation pgtype.Numeric     `db:"percentage_allocation"`
	Apy                  pgtype.Numeric     `db:"apy"`
	YieldEarned          pgtype.Numeric     `db:"yield_earned"`
	TxHash               *string            `db:"tx_hash"`
	Status               string             `db:"status"`
	DeployedAt           pgtype.Timestamptz `db:"deployed_at"`
	LastRebalanceAt      pgtype.Timestamptz `db:"last_rebalance_at"`
	WithdrawnAt          pgtype.Timestamptz `db:"withdrawn_at"`
	CreatedAt            pgtype.Timestamptz `db:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at"`
	ProtocolName         string             `db:"protocol_name"`
	ProtocolCategory     string             `db:"protocol_category"`
	ProtocolRiskLevel    string             `db:"protocol_risk_level"`
}

func (q *Queries) ListActiveAllocations(ctx context.Context, clientID uuid.UUID) ([]ListActiveAllocationsRow, error) {
	rows, err := q.db.Query(ctx, listActiveAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveAllocationsRow
	for rows.Next() {
		var i ListActiveAllocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ClientVaultID,
			&i.ProtocolID,
			&i.Category,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.Balance,
			&i.PercentageAllocation,
			&i.Apy,
			&i.YieldEarned,
			&i.TxHash,
			&i.Status,
			&i.DeployedAt,
			&i.LastRebalanceAt,
			&i.WithdrawnAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProtocolName,
			&i.ProtocolCategory,
			&i.ProtocolRiskLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveProtocols = `-- name: ListActiveProtocols :many
SELECT id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at FROM supported_defi_protocols
WHERE is_active = true
ORDER BY name ASC
`

func (q *Queries) ListActiveProtocols(ctx context.Context) ([]SupportedDefiProtocol, error) {
	rows, err := q.db.Query(ctx, listActiveProtocols)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupportedDefiProtocol
	for rows.Next() {
		var i SupportedDefiProtocol
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Chain,
			&i.AddressBook,
			&i.Category,
			&i.RiskLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllocations = `-- name: ListAllocations :many
SELECT id, client_id, client_vault_id, protocol_id, category, chain, token_address, token_symbol, balance, percentage_allocation, apy, yield_earned, tx_hash, status, deployed_at, last_rebalance_at, withdrawn_at, created_at, updated_at FROM defi_allocations
WHERE client_id = $1
ORDER BY deployed_at DESC
`

func (q *Queries) ListAllocations(ctx context.Context, clientID uuid.UUID) ([]DefiAllocation, error) {
	rows, err := q.db.Query(ctx, listAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DefiAllocation
	for rows.Next() {
		var i DefiAllocation
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ClientVaultID,
			&i.ProtocolID,
			&i.Category,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.Balance,
			&i.PercentageAllocation,
			&i.Apy,
			&i.YieldEarned,
			&i.TxHash,
			&i.Status,
			&i.DeployedAt,
			&i.LastRebalanceAt,
			&i.WithdrawnAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllocationsByCategory = `-- name: ListAllocationsByCategory :many
SELECT
  da.id, da.client_id, da.client_vault_id, da.protocol_id, da.category, da.chain, da.token_address, da.token_symbol, da.balance, da.percentage_allocation, da.apy, da.yield_earned, da.tx_hash, da.status, da.deployed_at, da.last_rebalance_at, da.withdrawn_at, da.created_at, da.updated_at,
  sdp.name AS protocol_name
FROM defi_allocations da
JOIN supported_defi_protocols sdp ON da.protocol_id = sdp.id
WHERE da.client_vault_id = $1
  AND da.category = $2
  AND da.status = 'active'
ORDER BY da.balance DESC
`

type ListAllocationsByCategoryParams struct {
	ClientVaultID uuid.UUID `db:"client_vault_id"`
	Category      string    `db:"category"`
}

type ListAllocationsByCategoryRow struct {
	ID                   uuid.UUID          `db:"id"`
	ClientID             uuid.UUID          `db:"client_id"`
	ClientVaultID        uuid.UUID          `db:"client_vault_id"`
	ProtocolID           uuid.UUID          `db:"protocol_id"`
	Category             string             `db:"category"`
	Chain                string             `db:"chain"`
	TokenAddress         string             `db:"token_address"`
	TokenSymbol          string             `db:"token_symbol"`
	Balance              pgtype.Numeric     `db:"balance"`
	PercentageAllocation pgtype.Numeric     `db:"percentage_allocation"`
	Apy                  pgtype.Numeric     `db:"apy"`
	YieldEarned          pgtype.Numeric     `db:"yield_earned"`
	TxHash               *string            `db:"tx_hash"`
	Status               string             `db:"status"`
	DeployedAt           pgtype.Timestamptz `db:"deployed_at"`
	LastRebalanceAt      pgtype.Timestamptz `db:"last_rebalance_at"`
	WithdrawnAt          pgtype.Timestamptz `db:"withdrawn_at"`
	CreatedAt            pgtype.Timestamptz `db:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at"`
	ProtocolName         string             `db:"protocol_name"`
}

func (q *Queries) ListAllocationsByCategory(ctx context.Context, arg ListAllocationsByCategoryParams) ([]ListAllocationsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listAllocationsByCategory, arg.ClientVaultID, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllocationsByCategoryRow
	for rows.Next() {
		var i ListAllocationsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ClientVaultID,
			&i.ProtocolID,
			&i.Category,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.Balance,
			&i.PercentageAllocation,
			&i.Apy,
			&i.YieldEarned,
			&i.TxHash,
			&i.Status,
			&i.DeployedAt,
			&i.LastRebalanceAt,
			&i.WithdrawnAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProtocolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllocationsByVault = `-- name: ListAllocationsByVault :many
SELECT
  da.id, da.client_id, da.client_vault_id, da.protocol_id, da.category, da.chain, da.token_address, da.token_symbol, da.balance, da.percentage_allocation, da.apy, da.yield_earned, da.tx_hash, da.status, da.deployed_at, da.last_rebalance_at, da.withdrawn_at, da.created_at, da.updated_at,
  sdp.name AS protocol_name,
  sdp.category AS protocol_category,
  sdp.risk_level AS protocol_risk_level
FROM defi_allocations da
JOIN supported_defi_protocols sdp ON da.protocol_id = sdp.id
WHERE da.client_vault_id = $1
ORDER BY da.balance DESC
`

type ListAllocationsByVaultRow struct {
	ID                   uuid.UUID          `db:"id"`
	ClientID             uuid.UUID          `db:"client_id"`
	ClientVaultID        uuid.UUID          `db:"client_vault_id"`
	ProtocolID           uuid.UUID          `db:"protocol_id"`
	Category             string             `db:"category"`
	Chain                string             `db:"chain"`
	TokenAddress         string             `db:"token_address"`
	TokenSymbol          string             `db:"token_symbol"`
	Balance              pgtype.Numeric     `db:"balance"`
	PercentageAllocation pgtype.Numeric     `db:"percentage_allocation"`
	Apy                  pgtype.Numeric     `db:"apy"`
	YieldEarned          pgtype.Numeric     `db:"yield_earned"`
	TxHash               *string            `db:"tx_hash"`
	Status               string             `db:"status"`
	DeployedAt           pgtype.Timestamptz `db:"deployed_at"`
	LastRebalanceAt      pgtype.Timestamptz `db:"last_rebalance_at"`
	WithdrawnAt          pgtype.Timestamptz `db:"withdrawn_at"`
	CreatedAt            pgtype.Timestamptz `db:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at"`
	ProtocolName         string             `db:"protocol_name"`
	ProtocolCategory     string             `db:"protocol_category"`
	ProtocolRiskLevel    string             `db:"protocol_risk_level"`
}

func (q *Queries) ListAllocationsByVault(ctx context.Context, clientVaultID uuid.UUID) ([]ListAllocationsByVaultRow, error) {
	rows, err := q.db.Query(ctx, listAllocationsByVault, clientVaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllocationsByVaultRow
	for rows.Next() {
		var i ListAllocationsByVaultRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ClientVaultID,
			&i.ProtocolID,
			&i.Category,
			&i.Chain,
			&i.TokenAddress,
			&i.TokenSymbol,
			&i.Balance,
			&i.PercentageAllocation,
			&i.Apy,
			&i.YieldEarned,
			&i.TxHash,
			&i.Status,
			&i.DeployedAt,
			&i.LastRebalanceAt,
			&i.WithdrawnAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProtocolName,
			&i.ProtocolCategory,
			&i.ProtocolRiskLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProtocols = `-- name: ListProtocols :many
SELECT id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at FROM supported_defi_protocols
ORDER BY name ASC
`

func (q *Queries) ListProtocols(ctx context.Context) ([]SupportedDefiProtocol, error) {
	rows, err := q.db.Query(ctx, listProtocols)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupportedDefiProtocol
	for rows.Next() {
		var i SupportedDefiProtocol
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Chain,
			&i.AddressBook,
			&i.Category,
			&i.RiskLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProtocolsByCategory = `-- name: ListProtocolsByCategory :many
SELECT id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at FROM supported_defi_protocols
WHERE category = $1
  AND is_active = true
ORDER BY name ASC
`

func (q *Queries) ListProtocolsByCategory(ctx context.Context, category string) ([]SupportedDefiProtocol, error) {
	rows, err := q.db.Query(ctx, listProtocolsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupportedDefiProtocol
	for rows.Next() {
		var i SupportedDefiProtocol
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Chain,
			&i.AddressBook,
			&i.Category,
			&i.RiskLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProtocolsByChain = `-- name: ListProtocolsByChain :many
SELECT id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at FROM supported_defi_protocols
WHERE chain = $1
  AND is_active = true
ORDER BY name ASC
`

func (q *Queries) ListProtocolsByChain(ctx context.Context, chain string) ([]SupportedDefiProtocol, error) {
	rows, err := q.db.Query(ctx, listProtocolsByChain, chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupportedDefiProtocol
	for rows.Next() {
		var i SupportedDefiProtocol
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Chain,
			&i.AddressBook,
			&i.Category,
			&i.RiskLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProtocolsByChainAndCategory = `-- name: ListProtocolsByChainAndCategory :many
SELECT id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at FROM supported_defi_protocols
WHERE chain = $1
  AND category = $2
  AND is_active = true
ORDER BY name ASC
`

type ListProtocolsByChainAndCategoryParams struct {
	Chain    string `db:"chain"`
	Category string `db:"category"`
}

func (q *Queries) ListProtocolsByChainAndCategory(ctx context.Context, arg ListProtocolsByChainAndCategoryParams) ([]SupportedDefiProtocol, error) {
	rows, err := q.db.Query(ctx, listProtocolsByChainAndCategory, arg.Chain, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SupportedDefiProtocol
	for rows.Next() {
		var i SupportedDefiProtocol
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Chain,
			&i.AddressBook,
			&i.Category,
			&i.RiskLevel,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllocationActive = `-- name: MarkAllocationActive :exec
UPDATE defi_allocations
SET status = 'active',
    last_rebalance_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkAllocationActive(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markAllocationActive, id)
	return err
}

const markAllocationRebalancing = `-- name: MarkAllocationRebalancing :exec
UPDATE defi_allocations
SET status = 'rebalancing',
    updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkAllocationRebalancing(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markAllocationRebalancing, id)
	return err
}

const updateAllocationAPY = `-- name: UpdateAllocationAPY :exec
UPDATE defi_allocations
SET apy = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateAllocationAPYParams struct {
	ID  uuid.UUID      `db:"id"`
	Apy pgtype.Numeric `db:"apy"`
}

func (q *Queries) UpdateAllocationAPY(ctx context.Context, arg UpdateAllocationAPYParams) error {
	_, err := q.db.Exec(ctx, updateAllocationAPY, arg.ID, arg.Apy)
	return err
}

const updateAllocationBalance = `-- name: UpdateAllocationBalance :exec
UPDATE defi_allocations
SET balance = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateAllocationBalanceParams struct {
	ID      uuid.UUID      `db:"id"`
	Balance pgtype.Numeric `db:"balance"`
}

func (q *Queries) UpdateAllocationBalance(ctx context.Context, arg UpdateAllocationBalanceParams) error {
	_, err := q.db.Exec(ctx, updateAllocationBalance, arg.ID, arg.Balance)
	return err
}

const updateAllocationYield = `-- name: UpdateAllocationYield :exec
UPDATE defi_allocations
SET balance = $2,
    yield_earned = yield_earned + $3,
    apy = COALESCE($4, apy),
    updated_at = now()
WHERE id = $1
`

type UpdateAllocationYieldParams struct {
	ID          uuid.UUID      `db:"id"`
	Balance     pgtype.Numeric `db:"balance"`
	YieldEarned pgtype.Numeric `db:"yield_earned"`
	Apy         pgtype.Numeric `db:"apy"`
}

func (q *Queries) UpdateAllocationYield(ctx context.Context, arg UpdateAllocationYieldParams) error {
	_, err := q.db.Exec(ctx, updateAllocationYield,
		arg.ID,
		arg.Balance,
		arg.YieldEarned,
		arg.Apy,
	)
	return err
}

const updateProtocol = `-- name: UpdateProtocol :one
UPDATE supported_defi_protocols
SET address_book = COALESCE($2, address_book),
    category = COALESCE($3, category),
    risk_level = COALESCE($4, risk_level),
    is_active = COALESCE($5, is_active),
    updated_at = now()
WHERE id = $1
RETURNING id, name, chain, address_book, category, risk_level, is_active, created_at, updated_at
`

type UpdateProtocolParams struct {
	ID          uuid.UUID `db:"id"`
	AddressBook []byte    `db:"address_book"`
	Category    *string   `db:"category"`
	RiskLevel   *string   `db:"risk_level"`
	IsActive    *bool     `db:"is_active"`
}

func (q *Queries) UpdateProtocol(ctx context.Context, arg UpdateProtocolParams) (SupportedDefiProtocol, error) {
	row := q.db.QueryRow(ctx, updateProtocol,
		arg.ID,
		arg.AddressBook,
		arg.Category,
		arg.RiskLevel,
		arg.IsActive,
	)
	var i SupportedDefiProtocol
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Chain,
		&i.AddressBook,
		&i.Category,
		&i.RiskLevel,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAllocation = `-- name: UpsertAllocation :one
INSERT INTO defi_allocations (
  client_id,
  client_vault_id,
  protocol_id,
  category,
  chain,
  token_address,
  token_symbol,
  balance,
  percentage_allocation,
  apy,
  tx_hash,
  status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
ON CONFLICT (client_vault_id, protocol_id)
DO UPDATE SET
  balance = defi_allocations.balance + EXCLUDED.balance,
  percentage_allocation = EXCLUDED.percentage_allocation,
  apy = EXCLUDED.apy,
  last_rebalance_at = now(),
  updated_at = now()
RETURNING id, client_id, client_vault_id, protocol_id, category, chain, token_address, token_symbol, balance, percentage_allocation, apy, yield_earned, tx_hash, status, deployed_at, last_rebalance_at, withdrawn_at, created_at, updated_at
`

type UpsertAllocationParams struct {
	ClientID             uuid.UUID      `db:"client_id"`
	ClientVaultID        uuid.UUID      `db:"client_vault_id"`
	ProtocolID           uuid.UUID      `db:"protocol_id"`
	Category             string         `db:"category"`
	Chain                string         `db:"chain"`
	TokenAddress         string         `db:"token_address"`
	TokenSymbol          string         `db:"token_symbol"`
	Balance              pgtype.Numeric `db:"balance"`
	PercentageAllocation pgtype.Numeric `db:"percentage_allocation"`
	Apy                  pgtype.Numeric `db:"apy"`
	TxHash               *string        `db:"tx_hash"`
	Status               string         `db:"status"`
}

// Create or update allocation (for rebalancing)
func (q *Queries) UpsertAllocation(ctx context.Context, arg UpsertAllocationParams) (DefiAllocation, error) {
	row := q.db.QueryRow(ctx, upsertAllocation,
		arg.ClientID,
		arg.ClientVaultID,
		arg.ProtocolID,
		arg.Category,
		arg.Chain,
		arg.TokenAddress,
		arg.TokenSymbol,
		arg.Balance,
		arg.PercentageAllocation,
		arg.Apy,
		arg.TxHash,
		arg.Status,
	)
	var i DefiAllocation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientVaultID,
		&i.ProtocolID,
		&i.Category,
		&i.Chain,
		&i.TokenAddress,
		&i.TokenSymbol,
		&i.Balance,
		&i.PercentageAllocation,
		&i.Apy,
		&i.YieldEarned,
		&i.TxHash,
		&i.Status,
		&i.DeployedAt,
		&i.LastRebalanceAt,
		&i.WithdrawnAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const withdrawAllocation = `-- name: WithdrawAllocation :exec
UPDATE defi_allocations
SET status = 'withdrawn',
    withdrawn_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) WithdrawAllocation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, withdrawAllocation, id)
	return err
}
