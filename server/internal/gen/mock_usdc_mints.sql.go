// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mock_usdc_mints.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMockUsdcMint = `-- name: CreateMockUsdcMint :one
INSERT INTO mock_usdc_mints (
  deposit_order_id,
  client_id,
  user_id,
  amount,
  chain,
  token_address,
  destination_wallet,
  mock_transaction_hash,
  block_number
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, deposit_order_id, client_id, user_id, amount, chain, token_address, destination_wallet, mock_transaction_hash, block_number, created_at
`

type CreateMockUsdcMintParams struct {
	DepositOrderID      uuid.UUID      `db:"deposit_order_id"`
	ClientID            uuid.UUID      `db:"client_id"`
	UserID              uuid.UUID      `db:"user_id"`
	Amount              pgtype.Numeric `db:"amount"`
	Chain               string         `db:"chain"`
	TokenAddress        string         `db:"token_address"`
	DestinationWallet   string         `db:"destination_wallet"`
	MockTransactionHash string         `db:"mock_transaction_hash"`
	BlockNumber         *int64         `db:"block_number"`
}

func (q *Queries) CreateMockUsdcMint(ctx context.Context, arg CreateMockUsdcMintParams) (MockUsdcMint, error) {
	row := q.db.QueryRow(ctx, createMockUsdcMint,
		arg.DepositOrderID,
		arg.ClientID,
		arg.UserID,
		arg.Amount,
		arg.Chain,
		arg.TokenAddress,
		arg.DestinationWallet,
		arg.MockTransactionHash,
		arg.BlockNumber,
	)
	var i MockUsdcMint
	err := row.Scan(
		&i.ID,
		&i.DepositOrderID,
		&i.ClientID,
		&i.UserID,
		&i.Amount,
		&i.Chain,
		&i.TokenAddress,
		&i.DestinationWallet,
		&i.MockTransactionHash,
		&i.BlockNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getMockMintStats = `-- name: GetMockMintStats :one
SELECT
  COUNT(*) AS total_mints,
  COALESCE(SUM(amount), 0) AS total_amount_minted,
  COALESCE(AVG(amount), 0) AS avg_mint_amount
FROM mock_usdc_mints
WHERE created_at >= $1
  AND created_at <= $2
`

type GetMockMintStatsParams struct {
	StartDate *time.Time `db:"start_date"`
	EndDate   *time.Time `db:"end_date"`
}

type GetMockMintStatsRow struct {
	TotalMints        int64       `db:"total_mints"`
	TotalAmountMinted interface{} `db:"total_amount_minted"`
	AvgMintAmount     interface{} `db:"avg_mint_amount"`
}

// Get mock mint statistics
func (q *Queries) GetMockMintStats(ctx context.Context, arg GetMockMintStatsParams) (GetMockMintStatsRow, error) {
	row := q.db.QueryRow(ctx, getMockMintStats, arg.StartDate, arg.EndDate)
	var i GetMockMintStatsRow
	err := row.Scan(&i.TotalMints, &i.TotalAmountMinted, &i.AvgMintAmount)
	return i, err
}

const getMockUsdcMint = `-- name: GetMockUsdcMint :one

SELECT id, deposit_order_id, client_id, user_id, amount, chain, token_address, destination_wallet, mock_transaction_hash, block_number, created_at FROM mock_usdc_mints
WHERE id = $1 LIMIT 1
`

// ============================================
// MOCK USDC MINTS QUERIES (For Oracle Service Demo)
// ============================================
func (q *Queries) GetMockUsdcMint(ctx context.Context, id uuid.UUID) (MockUsdcMint, error) {
	row := q.db.QueryRow(ctx, getMockUsdcMint, id)
	var i MockUsdcMint
	err := row.Scan(
		&i.ID,
		&i.DepositOrderID,
		&i.ClientID,
		&i.UserID,
		&i.Amount,
		&i.Chain,
		&i.TokenAddress,
		&i.DestinationWallet,
		&i.MockTransactionHash,
		&i.BlockNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getMockUsdcMintByDepositOrder = `-- name: GetMockUsdcMintByDepositOrder :one
SELECT id, deposit_order_id, client_id, user_id, amount, chain, token_address, destination_wallet, mock_transaction_hash, block_number, created_at FROM mock_usdc_mints
WHERE deposit_order_id = $1 LIMIT 1
`

func (q *Queries) GetMockUsdcMintByDepositOrder(ctx context.Context, depositOrderID uuid.UUID) (MockUsdcMint, error) {
	row := q.db.QueryRow(ctx, getMockUsdcMintByDepositOrder, depositOrderID)
	var i MockUsdcMint
	err := row.Scan(
		&i.ID,
		&i.DepositOrderID,
		&i.ClientID,
		&i.UserID,
		&i.Amount,
		&i.Chain,
		&i.TokenAddress,
		&i.DestinationWallet,
		&i.MockTransactionHash,
		&i.BlockNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getMockUsdcMintByTxHash = `-- name: GetMockUsdcMintByTxHash :one
SELECT id, deposit_order_id, client_id, user_id, amount, chain, token_address, destination_wallet, mock_transaction_hash, block_number, created_at FROM mock_usdc_mints
WHERE mock_transaction_hash = $1 LIMIT 1
`

func (q *Queries) GetMockUsdcMintByTxHash(ctx context.Context, mockTransactionHash string) (MockUsdcMint, error) {
	row := q.db.QueryRow(ctx, getMockUsdcMintByTxHash, mockTransactionHash)
	var i MockUsdcMint
	err := row.Scan(
		&i.ID,
		&i.DepositOrderID,
		&i.ClientID,
		&i.UserID,
		&i.Amount,
		&i.Chain,
		&i.TokenAddress,
		&i.DestinationWallet,
		&i.MockTransactionHash,
		&i.BlockNumber,
		&i.CreatedAt,
	)
	return i, err
}

const listMockUsdcMintsByClient = `-- name: ListMockUsdcMintsByClient :many
SELECT id, deposit_order_id, client_id, user_id, amount, chain, token_address, destination_wallet, mock_transaction_hash, block_number, created_at FROM mock_usdc_mints
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMockUsdcMintsByClientParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListMockUsdcMintsByClient(ctx context.Context, arg ListMockUsdcMintsByClientParams) ([]MockUsdcMint, error) {
	rows, err := q.db.Query(ctx, listMockUsdcMintsByClient, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MockUsdcMint
	for rows.Next() {
		var i MockUsdcMint
		if err := rows.Scan(
			&i.ID,
			&i.DepositOrderID,
			&i.ClientID,
			&i.UserID,
			&i.Amount,
			&i.Chain,
			&i.TokenAddress,
			&i.DestinationWallet,
			&i.MockTransactionHash,
			&i.BlockNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMockUsdcMintsByUser = `-- name: ListMockUsdcMintsByUser :many
SELECT id, deposit_order_id, client_id, user_id, amount, chain, token_address, destination_wallet, mock_transaction_hash, block_number, created_at FROM mock_usdc_mints
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListMockUsdcMintsByUserParams struct {
	UserID uuid.UUID `db:"user_id"`
	Limit  int32     `db:"limit"`
	Offset int32     `db:"offset"`
}

func (q *Queries) ListMockUsdcMintsByUser(ctx context.Context, arg ListMockUsdcMintsByUserParams) ([]MockUsdcMint, error) {
	rows, err := q.db.Query(ctx, listMockUsdcMintsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MockUsdcMint
	for rows.Next() {
		var i MockUsdcMint
		if err := rows.Scan(
			&i.ID,
			&i.DepositOrderID,
			&i.ClientID,
			&i.UserID,
			&i.Amount,
			&i.Chain,
			&i.TokenAddress,
			&i.DestinationWallet,
			&i.MockTransactionHash,
			&i.BlockNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentMockMints = `-- name: ListRecentMockMints :many
SELECT id, deposit_order_id, client_id, user_id, amount, chain, token_address, destination_wallet, mock_transaction_hash, block_number, created_at FROM mock_usdc_mints
ORDER BY created_at DESC
LIMIT $1
`

// Get recent mock mints for operations monitoring
func (q *Queries) ListRecentMockMints(ctx context.Context, limit int32) ([]MockUsdcMint, error) {
	rows, err := q.db.Query(ctx, listRecentMockMints, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MockUsdcMint
	for rows.Next() {
		var i MockUsdcMint
		if err := rows.Scan(
			&i.ID,
			&i.DepositOrderID,
			&i.ClientID,
			&i.UserID,
			&i.Amount,
			&i.Chain,
			&i.TokenAddress,
			&i.DestinationWallet,
			&i.MockTransactionHash,
			&i.BlockNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
