// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: end_user.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateEndUser = `-- name: ActivateEndUser :exec
UPDATE end_users
SET is_active = true,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) ActivateEndUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateEndUser, id)
	return err
}

const createEndUser = `-- name: CreateEndUser :one
INSERT INTO end_users (
  client_id,
  user_id,
  user_type,
  user_wallet_address,
  is_active
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, client_id, user_id, user_type, user_wallet_address, is_active, first_deposit_at, last_deposit_at, last_withdrawal_at, created_at, updated_at
`

type CreateEndUserParams struct {
	ClientID          uuid.UUID `db:"client_id"`
	UserID            string    `db:"user_id"`
	UserType          string    `db:"user_type"`
	UserWalletAddress *string   `db:"user_wallet_address"`
	IsActive          bool      `db:"is_active"`
}

func (q *Queries) CreateEndUser(ctx context.Context, arg CreateEndUserParams) (EndUser, error) {
	row := q.db.QueryRow(ctx, createEndUser,
		arg.ClientID,
		arg.UserID,
		arg.UserType,
		arg.UserWalletAddress,
		arg.IsActive,
	)
	var i EndUser
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.UserType,
		&i.UserWalletAddress,
		&i.IsActive,
		&i.FirstDepositAt,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateEndUser = `-- name: DeactivateEndUser :exec
UPDATE end_users
SET is_active = false,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) DeactivateEndUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateEndUser, id)
	return err
}

const deleteEndUser = `-- name: DeleteEndUser :exec
DELETE FROM end_users
WHERE id = $1
`

func (q *Queries) DeleteEndUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEndUser, id)
	return err
}

const getEndUser = `-- name: GetEndUser :one

SELECT id, client_id, user_id, user_type, user_wallet_address, is_active, first_deposit_at, last_deposit_at, last_withdrawal_at, created_at, updated_at FROM end_users
WHERE id = $1 LIMIT 1
`

// ============================================
// END-USER QUERIES
// ============================================
func (q *Queries) GetEndUser(ctx context.Context, id uuid.UUID) (EndUser, error) {
	row := q.db.QueryRow(ctx, getEndUser, id)
	var i EndUser
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.UserType,
		&i.UserWalletAddress,
		&i.IsActive,
		&i.FirstDepositAt,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserByClientAndUserID = `-- name: GetEndUserByClientAndUserID :one
SELECT id, client_id, user_id, user_type, user_wallet_address, is_active, first_deposit_at, last_deposit_at, last_withdrawal_at, created_at, updated_at FROM end_users
WHERE client_id = $1
  AND user_id = $2
LIMIT 1
`

type GetEndUserByClientAndUserIDParams struct {
	ClientID uuid.UUID `db:"client_id"`
	UserID   string    `db:"user_id"`
}

func (q *Queries) GetEndUserByClientAndUserID(ctx context.Context, arg GetEndUserByClientAndUserIDParams) (EndUser, error) {
	row := q.db.QueryRow(ctx, getEndUserByClientAndUserID, arg.ClientID, arg.UserID)
	var i EndUser
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.UserType,
		&i.UserWalletAddress,
		&i.IsActive,
		&i.FirstDepositAt,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndUserPortfolio = `-- name: GetEndUserPortfolio :one

SELECT
  eu.id,
  eu.user_id,
  eu.client_id,
  eu.user_type,
  eu.first_deposit_at,
  eu.last_deposit_at,
  eu.last_withdrawal_at,
  COUNT(DISTINCT euv.id) AS total_vaults,
  COALESCE(SUM(euv.total_deposited), 0) AS total_deposited,
  COALESCE(SUM(euv.total_withdrawn), 0) AS total_withdrawn,
  COALESCE(SUM(euv.shares * cv.current_index / 1000000000000000000), 0) AS total_effective_balance,
  COALESCE(SUM((euv.shares * cv.current_index / 1000000000000000000) - euv.total_deposited), 0) AS total_yield_earned
FROM end_users eu
LEFT JOIN end_user_vaults euv ON eu.id = euv.end_user_id AND euv.is_active = true
LEFT JOIN client_vaults cv
  ON euv.client_id = cv.client_id
  AND euv.chain = cv.chain
  AND euv.token_address = cv.token_address
WHERE eu.id = $1
GROUP BY eu.id
`

type GetEndUserPortfolioRow struct {
	ID                    uuid.UUID          `db:"id"`
	UserID                string             `db:"user_id"`
	ClientID              uuid.UUID          `db:"client_id"`
	UserType              string             `db:"user_type"`
	FirstDepositAt        pgtype.Timestamptz `db:"first_deposit_at"`
	LastDepositAt         pgtype.Timestamptz `db:"last_deposit_at"`
	LastWithdrawalAt      pgtype.Timestamptz `db:"last_withdrawal_at"`
	TotalVaults           int64              `db:"total_vaults"`
	TotalDeposited        interface{}        `db:"total_deposited"`
	TotalWithdrawn        interface{}        `db:"total_withdrawn"`
	TotalEffectiveBalance interface{}        `db:"total_effective_balance"`
	TotalYieldEarned      interface{}        `db:"total_yield_earned"`
}

// ============================================
// END-USER ANALYTICS
// ============================================
// Complete portfolio summary for an end-user
func (q *Queries) GetEndUserPortfolio(ctx context.Context, id uuid.UUID) (GetEndUserPortfolioRow, error) {
	row := q.db.QueryRow(ctx, getEndUserPortfolio, id)
	var i GetEndUserPortfolioRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ClientID,
		&i.UserType,
		&i.FirstDepositAt,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.TotalVaults,
		&i.TotalDeposited,
		&i.TotalWithdrawn,
		&i.TotalEffectiveBalance,
		&i.TotalYieldEarned,
	)
	return i, err
}

const listActiveEndUsers = `-- name: ListActiveEndUsers :many
SELECT id, client_id, user_id, user_type, user_wallet_address, is_active, first_deposit_at, last_deposit_at, last_withdrawal_at, created_at, updated_at FROM end_users
WHERE client_id = $1
  AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListActiveEndUsers(ctx context.Context, clientID uuid.UUID) ([]EndUser, error) {
	rows, err := q.db.Query(ctx, listActiveEndUsers, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EndUser
	for rows.Next() {
		var i EndUser
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.UserType,
			&i.UserWalletAddress,
			&i.IsActive,
			&i.FirstDepositAt,
			&i.LastDepositAt,
			&i.LastWithdrawalAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEndUsers = `-- name: ListEndUsers :many
SELECT id, client_id, user_id, user_type, user_wallet_address, is_active, first_deposit_at, last_deposit_at, last_withdrawal_at, created_at, updated_at FROM end_users
WHERE client_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEndUsersParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

func (q *Queries) ListEndUsers(ctx context.Context, arg ListEndUsersParams) ([]EndUser, error) {
	rows, err := q.db.Query(ctx, listEndUsers, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EndUser
	for rows.Next() {
		var i EndUser
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.UserID,
			&i.UserType,
			&i.UserWalletAddress,
			&i.IsActive,
			&i.FirstDepositAt,
			&i.LastDepositAt,
			&i.LastWithdrawalAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEndUsersWithBalances = `-- name: ListEndUsersWithBalances :many
SELECT
  eu.id,
  eu.user_id,
  eu.user_type,
  eu.is_active,
  eu.first_deposit_at,
  eu.last_deposit_at,
  COALESCE(SUM(euv.shares * cv.current_index / 1000000000000000000), 0) AS total_balance,
  COALESCE(SUM(euv.total_deposited), 0) AS total_deposited,
  COALESCE(SUM((euv.shares * cv.current_index / 1000000000000000000) - euv.total_deposited), 0) AS total_yield
FROM end_users eu
LEFT JOIN end_user_vaults euv ON eu.id = euv.end_user_id AND euv.is_active = true
LEFT JOIN client_vaults cv
  ON euv.client_id = cv.client_id
  AND euv.chain = cv.chain
  AND euv.token_address = cv.token_address
WHERE eu.client_id = $1
GROUP BY eu.id
ORDER BY total_balance DESC
LIMIT $2 OFFSET $3
`

type ListEndUsersWithBalancesParams struct {
	ClientID uuid.UUID `db:"client_id"`
	Limit    int32     `db:"limit"`
	Offset   int32     `db:"offset"`
}

type ListEndUsersWithBalancesRow struct {
	ID             uuid.UUID          `db:"id"`
	UserID         string             `db:"user_id"`
	UserType       string             `db:"user_type"`
	IsActive       bool               `db:"is_active"`
	FirstDepositAt pgtype.Timestamptz `db:"first_deposit_at"`
	LastDepositAt  pgtype.Timestamptz `db:"last_deposit_at"`
	TotalBalance   interface{}        `db:"total_balance"`
	TotalDeposited interface{}        `db:"total_deposited"`
	TotalYield     interface{}        `db:"total_yield"`
}

// Get all end-users for a client with their total balances
func (q *Queries) ListEndUsersWithBalances(ctx context.Context, arg ListEndUsersWithBalancesParams) ([]ListEndUsersWithBalancesRow, error) {
	rows, err := q.db.Query(ctx, listEndUsersWithBalances, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEndUsersWithBalancesRow
	for rows.Next() {
		var i ListEndUsersWithBalancesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserType,
			&i.IsActive,
			&i.FirstDepositAt,
			&i.LastDepositAt,
			&i.TotalBalance,
			&i.TotalDeposited,
			&i.TotalYield,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setFirstDeposit = `-- name: SetFirstDeposit :exec
UPDATE end_users
SET first_deposit_at = COALESCE(first_deposit_at, now()),
    last_deposit_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) SetFirstDeposit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setFirstDeposit, id)
	return err
}

const updateEndUser = `-- name: UpdateEndUser :one
UPDATE end_users
SET user_wallet_address = COALESCE($2, user_wallet_address),
    is_active = COALESCE($3, is_active),
    updated_at = now()
WHERE id = $1
RETURNING id, client_id, user_id, user_type, user_wallet_address, is_active, first_deposit_at, last_deposit_at, last_withdrawal_at, created_at, updated_at
`

type UpdateEndUserParams struct {
	ID                uuid.UUID `db:"id"`
	UserWalletAddress *string   `db:"user_wallet_address"`
	IsActive          *bool     `db:"is_active"`
}

func (q *Queries) UpdateEndUser(ctx context.Context, arg UpdateEndUserParams) (EndUser, error) {
	row := q.db.QueryRow(ctx, updateEndUser, arg.ID, arg.UserWalletAddress, arg.IsActive)
	var i EndUser
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.UserID,
		&i.UserType,
		&i.UserWalletAddress,
		&i.IsActive,
		&i.FirstDepositAt,
		&i.LastDepositAt,
		&i.LastWithdrawalAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEndUserDepositTimestamp = `-- name: UpdateEndUserDepositTimestamp :exec
UPDATE end_users
SET last_deposit_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) UpdateEndUserDepositTimestamp(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateEndUserDepositTimestamp, id)
	return err
}

const updateEndUserWithdrawalTimestamp = `-- name: UpdateEndUserWithdrawalTimestamp :exec
UPDATE end_users
SET last_withdrawal_at = now(),
    updated_at = now()
WHERE id = $1
`

func (q *Queries) UpdateEndUserWithdrawalTimestamp(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateEndUserWithdrawalTimestamp, id)
	return err
}
