// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: client.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const activateClient = `-- name: ActivateClient :exec
UPDATE client_organizations
SET is_active = true,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) ActivateClient(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateClient, id)
	return err
}

const addToAvailableBalance = `-- name: AddToAvailableBalance :exec
UPDATE client_balances
SET available = available + $2,
    last_topup_at = now(),
    updated_at = now()
WHERE client_id = $1
`

type AddToAvailableBalanceParams struct {
	ClientID  uuid.UUID      `db:"client_id"`
	Available pgtype.Numeric `db:"available"`
}

func (q *Queries) AddToAvailableBalance(ctx context.Context, arg AddToAvailableBalanceParams) error {
	_, err := q.db.Exec(ctx, addToAvailableBalance, arg.ClientID, arg.Available)
	return err
}

const createClient = `-- name: CreateClient :one
INSERT INTO client_organizations (
  privy_account_id,
  product_id,
  company_name,
  business_type,
  description,
  website_url,
  api_key_hash,
  api_key_prefix,
  webhook_urls,
  webhook_secret,
  custom_strategy,
  end_user_yield_portion,
  platform_fee,
  performance_fee,
  is_active,
  is_sandbox,
  supported_currencies,
  bank_accounts
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
  $11, $12, $13, $14, $15, $16, $17, $18
)
RETURNING id, privy_account_id, product_id, company_name, business_type, description, website_url, api_key_hash, api_key_prefix, webhook_urls, webhook_secret, custom_strategy, end_user_yield_portion, is_active, is_sandbox, platform_fee, performance_fee, created_at, updated_at, supported_currencies, bank_accounts
`

type CreateClientParams struct {
	PrivyAccountID      uuid.UUID      `db:"privy_account_id"`
	ProductID           string         `db:"product_id"`
	CompanyName         string         `db:"company_name"`
	BusinessType        string         `db:"business_type"`
	Description         *string        `db:"description"`
	WebsiteUrl          *string        `db:"website_url"`
	ApiKeyHash          *string        `db:"api_key_hash"`
	ApiKeyPrefix        *string        `db:"api_key_prefix"`
	WebhookUrls         []string       `db:"webhook_urls"`
	WebhookSecret       *string        `db:"webhook_secret"`
	CustomStrategy      []byte         `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric `db:"end_user_yield_portion"`
	PlatformFee         pgtype.Numeric `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric `db:"performance_fee"`
	IsActive            bool           `db:"is_active"`
	IsSandbox           bool           `db:"is_sandbox"`
	SupportedCurrencies []string       `db:"supported_currencies"`
	BankAccounts        []byte         `db:"bank_accounts"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (ClientOrganization, error) {
	row := q.db.QueryRow(ctx, createClient,
		arg.PrivyAccountID,
		arg.ProductID,
		arg.CompanyName,
		arg.BusinessType,
		arg.Description,
		arg.WebsiteUrl,
		arg.ApiKeyHash,
		arg.ApiKeyPrefix,
		arg.WebhookUrls,
		arg.WebhookSecret,
		arg.CustomStrategy,
		arg.EndUserYieldPortion,
		arg.PlatformFee,
		arg.PerformanceFee,
		arg.IsActive,
		arg.IsSandbox,
		arg.SupportedCurrencies,
		arg.BankAccounts,
	)
	var i ClientOrganization
	err := row.Scan(
		&i.ID,
		&i.PrivyAccountID,
		&i.ProductID,
		&i.CompanyName,
		&i.BusinessType,
		&i.Description,
		&i.WebsiteUrl,
		&i.ApiKeyHash,
		&i.ApiKeyPrefix,
		&i.WebhookUrls,
		&i.WebhookSecret,
		&i.CustomStrategy,
		&i.EndUserYieldPortion,
		&i.IsActive,
		&i.IsSandbox,
		&i.PlatformFee,
		&i.PerformanceFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupportedCurrencies,
		&i.BankAccounts,
	)
	return i, err
}

const createClientBalance = `-- name: CreateClientBalance :one
INSERT INTO client_balances (
  client_id,
  available,
  reserved,
  currency
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, client_id, available, reserved, currency, last_topup_at, created_at, updated_at
`

type CreateClientBalanceParams struct {
	ClientID  uuid.UUID      `db:"client_id"`
	Available pgtype.Numeric `db:"available"`
	Reserved  pgtype.Numeric `db:"reserved"`
	Currency  string         `db:"currency"`
}

func (q *Queries) CreateClientBalance(ctx context.Context, arg CreateClientBalanceParams) (ClientBalance, error) {
	row := q.db.QueryRow(ctx, createClientBalance,
		arg.ClientID,
		arg.Available,
		arg.Reserved,
		arg.Currency,
	)
	var i ClientBalance
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Available,
		&i.Reserved,
		&i.Currency,
		&i.LastTopupAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateClient = `-- name: DeactivateClient :exec
UPDATE client_organizations
SET is_active = false,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) DeactivateClient(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateClient, id)
	return err
}

const deductFromAvailable = `-- name: DeductFromAvailable :exec
UPDATE client_balances
SET available = available - $2,
    updated_at = now()
WHERE client_id = $1
  AND available >= $2
`

type DeductFromAvailableParams struct {
	ClientID  uuid.UUID      `db:"client_id"`
	Available pgtype.Numeric `db:"available"`
}

// Direct deduction from available balance
func (q *Queries) DeductFromAvailable(ctx context.Context, arg DeductFromAvailableParams) error {
	_, err := q.db.Exec(ctx, deductFromAvailable, arg.ClientID, arg.Available)
	return err
}

const deductReservedBalance = `-- name: DeductReservedBalance :exec
UPDATE client_balances
SET reserved = reserved - $2,
    updated_at = now()
WHERE client_id = $1
  AND reserved >= $2
`

type DeductReservedBalanceParams struct {
	ClientID uuid.UUID      `db:"client_id"`
	Reserved pgtype.Numeric `db:"reserved"`
}

// Remove from reserved (transaction completed)
func (q *Queries) DeductReservedBalance(ctx context.Context, arg DeductReservedBalanceParams) error {
	_, err := q.db.Exec(ctx, deductReservedBalance, arg.ClientID, arg.Reserved)
	return err
}

const deleteClient = `-- name: DeleteClient :exec
DELETE FROM client_organizations
WHERE id = $1
`

func (q *Queries) DeleteClient(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteClient, id)
	return err
}

const getClient = `-- name: GetClient :one

SELECT
  co.id, co.privy_account_id, co.product_id, co.company_name, co.business_type, co.description, co.website_url, co.api_key_hash, co.api_key_prefix, co.webhook_urls, co.webhook_secret, co.custom_strategy, co.end_user_yield_portion, co.is_active, co.is_sandbox, co.platform_fee, co.performance_fee, co.created_at, co.updated_at, co.supported_currencies, co.bank_accounts,
  pa.privy_organization_id,
  pa.privy_wallet_address,
  pa.privy_email,
  pa.wallet_type AS privy_wallet_type
FROM client_organizations co
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE co.id = $1
LIMIT 1
`

type GetClientRow struct {
	ID                  uuid.UUID          `db:"id"`
	PrivyAccountID      uuid.UUID          `db:"privy_account_id"`
	ProductID           string             `db:"product_id"`
	CompanyName         string             `db:"company_name"`
	BusinessType        string             `db:"business_type"`
	Description         *string            `db:"description"`
	WebsiteUrl          *string            `db:"website_url"`
	ApiKeyHash          *string            `db:"api_key_hash"`
	ApiKeyPrefix        *string            `db:"api_key_prefix"`
	WebhookUrls         []string           `db:"webhook_urls"`
	WebhookSecret       *string            `db:"webhook_secret"`
	CustomStrategy      []byte             `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric     `db:"end_user_yield_portion"`
	IsActive            bool               `db:"is_active"`
	IsSandbox           bool               `db:"is_sandbox"`
	PlatformFee         pgtype.Numeric     `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric     `db:"performance_fee"`
	CreatedAt           pgtype.Timestamptz `db:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at"`
	SupportedCurrencies []string           `db:"supported_currencies"`
	BankAccounts        []byte             `db:"bank_accounts"`
	PrivyOrganizationID string             `db:"privy_organization_id"`
	PrivyWalletAddress  string             `db:"privy_wallet_address"`
	PrivyEmail          *string            `db:"privy_email"`
	PrivyWalletType     string             `db:"privy_wallet_type"`
}

// ============================================
// CLIENT ORGANIZATION QUERIES
// ============================================
func (q *Queries) GetClient(ctx context.Context, id uuid.UUID) (GetClientRow, error) {
	row := q.db.QueryRow(ctx, getClient, id)
	var i GetClientRow
	err := row.Scan(
		&i.ID,
		&i.PrivyAccountID,
		&i.ProductID,
		&i.CompanyName,
		&i.BusinessType,
		&i.Description,
		&i.WebsiteUrl,
		&i.ApiKeyHash,
		&i.ApiKeyPrefix,
		&i.WebhookUrls,
		&i.WebhookSecret,
		&i.CustomStrategy,
		&i.EndUserYieldPortion,
		&i.IsActive,
		&i.IsSandbox,
		&i.PlatformFee,
		&i.PerformanceFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupportedCurrencies,
		&i.BankAccounts,
		&i.PrivyOrganizationID,
		&i.PrivyWalletAddress,
		&i.PrivyEmail,
		&i.PrivyWalletType,
	)
	return i, err
}

const getClientBalance = `-- name: GetClientBalance :one

SELECT id, client_id, available, reserved, currency, last_topup_at, created_at, updated_at FROM client_balances
WHERE client_id = $1 LIMIT 1
`

// ============================================
// CLIENT BALANCE QUERIES
// ============================================
func (q *Queries) GetClientBalance(ctx context.Context, clientID uuid.UUID) (ClientBalance, error) {
	row := q.db.QueryRow(ctx, getClientBalance, clientID)
	var i ClientBalance
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Available,
		&i.Reserved,
		&i.Currency,
		&i.LastTopupAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientBalanceForUpdate = `-- name: GetClientBalanceForUpdate :one
SELECT id, client_id, available, reserved, currency, last_topup_at, created_at, updated_at FROM client_balances
WHERE client_id = $1
FOR UPDATE
LIMIT 1
`

// Use in transactions to lock the balance row
func (q *Queries) GetClientBalanceForUpdate(ctx context.Context, clientID uuid.UUID) (ClientBalance, error) {
	row := q.db.QueryRow(ctx, getClientBalanceForUpdate, clientID)
	var i ClientBalance
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Available,
		&i.Reserved,
		&i.Currency,
		&i.LastTopupAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientByAPIKeyHash = `-- name: GetClientByAPIKeyHash :one
SELECT
  co.id, co.privy_account_id, co.product_id, co.company_name, co.business_type, co.description, co.website_url, co.api_key_hash, co.api_key_prefix, co.webhook_urls, co.webhook_secret, co.custom_strategy, co.end_user_yield_portion, co.is_active, co.is_sandbox, co.platform_fee, co.performance_fee, co.created_at, co.updated_at, co.supported_currencies, co.bank_accounts,
  pa.privy_organization_id,
  pa.privy_wallet_address,
  pa.privy_email,
  pa.wallet_type AS privy_wallet_type
FROM client_organizations co
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE co.api_key_hash = $1
LIMIT 1
`

type GetClientByAPIKeyHashRow struct {
	ID                  uuid.UUID          `db:"id"`
	PrivyAccountID      uuid.UUID          `db:"privy_account_id"`
	ProductID           string             `db:"product_id"`
	CompanyName         string             `db:"company_name"`
	BusinessType        string             `db:"business_type"`
	Description         *string            `db:"description"`
	WebsiteUrl          *string            `db:"website_url"`
	ApiKeyHash          *string            `db:"api_key_hash"`
	ApiKeyPrefix        *string            `db:"api_key_prefix"`
	WebhookUrls         []string           `db:"webhook_urls"`
	WebhookSecret       *string            `db:"webhook_secret"`
	CustomStrategy      []byte             `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric     `db:"end_user_yield_portion"`
	IsActive            bool               `db:"is_active"`
	IsSandbox           bool               `db:"is_sandbox"`
	PlatformFee         pgtype.Numeric     `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric     `db:"performance_fee"`
	CreatedAt           pgtype.Timestamptz `db:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at"`
	SupportedCurrencies []string           `db:"supported_currencies"`
	BankAccounts        []byte             `db:"bank_accounts"`
	PrivyOrganizationID string             `db:"privy_organization_id"`
	PrivyWalletAddress  string             `db:"privy_wallet_address"`
	PrivyEmail          *string            `db:"privy_email"`
	PrivyWalletType     string             `db:"privy_wallet_type"`
}

// Direct lookup by API key hash
func (q *Queries) GetClientByAPIKeyHash(ctx context.Context, apiKeyHash *string) (GetClientByAPIKeyHashRow, error) {
	row := q.db.QueryRow(ctx, getClientByAPIKeyHash, apiKeyHash)
	var i GetClientByAPIKeyHashRow
	err := row.Scan(
		&i.ID,
		&i.PrivyAccountID,
		&i.ProductID,
		&i.CompanyName,
		&i.BusinessType,
		&i.Description,
		&i.WebsiteUrl,
		&i.ApiKeyHash,
		&i.ApiKeyPrefix,
		&i.WebhookUrls,
		&i.WebhookSecret,
		&i.CustomStrategy,
		&i.EndUserYieldPortion,
		&i.IsActive,
		&i.IsSandbox,
		&i.PlatformFee,
		&i.PerformanceFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupportedCurrencies,
		&i.BankAccounts,
		&i.PrivyOrganizationID,
		&i.PrivyWalletAddress,
		&i.PrivyEmail,
		&i.PrivyWalletType,
	)
	return i, err
}

const getClientByAPIKeyPrefix = `-- name: GetClientByAPIKeyPrefix :one
SELECT
  co.id, co.privy_account_id, co.product_id, co.company_name, co.business_type, co.description, co.website_url, co.api_key_hash, co.api_key_prefix, co.webhook_urls, co.webhook_secret, co.custom_strategy, co.end_user_yield_portion, co.is_active, co.is_sandbox, co.platform_fee, co.performance_fee, co.created_at, co.updated_at, co.supported_currencies, co.bank_accounts,
  pa.privy_organization_id,
  pa.privy_wallet_address,
  pa.privy_email,
  pa.wallet_type AS privy_wallet_type
FROM client_organizations co
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE co.api_key_prefix = $1
LIMIT 1
`

type GetClientByAPIKeyPrefixRow struct {
	ID                  uuid.UUID          `db:"id"`
	PrivyAccountID      uuid.UUID          `db:"privy_account_id"`
	ProductID           string             `db:"product_id"`
	CompanyName         string             `db:"company_name"`
	BusinessType        string             `db:"business_type"`
	Description         *string            `db:"description"`
	WebsiteUrl          *string            `db:"website_url"`
	ApiKeyHash          *string            `db:"api_key_hash"`
	ApiKeyPrefix        *string            `db:"api_key_prefix"`
	WebhookUrls         []string           `db:"webhook_urls"`
	WebhookSecret       *string            `db:"webhook_secret"`
	CustomStrategy      []byte             `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric     `db:"end_user_yield_portion"`
	IsActive            bool               `db:"is_active"`
	IsSandbox           bool               `db:"is_sandbox"`
	PlatformFee         pgtype.Numeric     `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric     `db:"performance_fee"`
	CreatedAt           pgtype.Timestamptz `db:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at"`
	SupportedCurrencies []string           `db:"supported_currencies"`
	BankAccounts        []byte             `db:"bank_accounts"`
	PrivyOrganizationID string             `db:"privy_organization_id"`
	PrivyWalletAddress  string             `db:"privy_wallet_address"`
	PrivyEmail          *string            `db:"privy_email"`
	PrivyWalletType     string             `db:"privy_wallet_type"`
}

// For API key validation (then verify hash)
func (q *Queries) GetClientByAPIKeyPrefix(ctx context.Context, apiKeyPrefix *string) (GetClientByAPIKeyPrefixRow, error) {
	row := q.db.QueryRow(ctx, getClientByAPIKeyPrefix, apiKeyPrefix)
	var i GetClientByAPIKeyPrefixRow
	err := row.Scan(
		&i.ID,
		&i.PrivyAccountID,
		&i.ProductID,
		&i.CompanyName,
		&i.BusinessType,
		&i.Description,
		&i.WebsiteUrl,
		&i.ApiKeyHash,
		&i.ApiKeyPrefix,
		&i.WebhookUrls,
		&i.WebhookSecret,
		&i.CustomStrategy,
		&i.EndUserYieldPortion,
		&i.IsActive,
		&i.IsSandbox,
		&i.PlatformFee,
		&i.PerformanceFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupportedCurrencies,
		&i.BankAccounts,
		&i.PrivyOrganizationID,
		&i.PrivyWalletAddress,
		&i.PrivyEmail,
		&i.PrivyWalletType,
	)
	return i, err
}

const getClientByProductID = `-- name: GetClientByProductID :one
SELECT
  co.id, co.privy_account_id, co.product_id, co.company_name, co.business_type, co.description, co.website_url, co.api_key_hash, co.api_key_prefix, co.webhook_urls, co.webhook_secret, co.custom_strategy, co.end_user_yield_portion, co.is_active, co.is_sandbox, co.platform_fee, co.performance_fee, co.created_at, co.updated_at, co.supported_currencies, co.bank_accounts,
  pa.privy_organization_id,
  pa.privy_wallet_address,
  pa.privy_email,
  pa.wallet_type AS privy_wallet_type
FROM client_organizations co
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE co.product_id = $1
LIMIT 1
`

type GetClientByProductIDRow struct {
	ID                  uuid.UUID          `db:"id"`
	PrivyAccountID      uuid.UUID          `db:"privy_account_id"`
	ProductID           string             `db:"product_id"`
	CompanyName         string             `db:"company_name"`
	BusinessType        string             `db:"business_type"`
	Description         *string            `db:"description"`
	WebsiteUrl          *string            `db:"website_url"`
	ApiKeyHash          *string            `db:"api_key_hash"`
	ApiKeyPrefix        *string            `db:"api_key_prefix"`
	WebhookUrls         []string           `db:"webhook_urls"`
	WebhookSecret       *string            `db:"webhook_secret"`
	CustomStrategy      []byte             `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric     `db:"end_user_yield_portion"`
	IsActive            bool               `db:"is_active"`
	IsSandbox           bool               `db:"is_sandbox"`
	PlatformFee         pgtype.Numeric     `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric     `db:"performance_fee"`
	CreatedAt           pgtype.Timestamptz `db:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at"`
	SupportedCurrencies []string           `db:"supported_currencies"`
	BankAccounts        []byte             `db:"bank_accounts"`
	PrivyOrganizationID string             `db:"privy_organization_id"`
	PrivyWalletAddress  string             `db:"privy_wallet_address"`
	PrivyEmail          *string            `db:"privy_email"`
	PrivyWalletType     string             `db:"privy_wallet_type"`
}

func (q *Queries) GetClientByProductID(ctx context.Context, productID string) (GetClientByProductIDRow, error) {
	row := q.db.QueryRow(ctx, getClientByProductID, productID)
	var i GetClientByProductIDRow
	err := row.Scan(
		&i.ID,
		&i.PrivyAccountID,
		&i.ProductID,
		&i.CompanyName,
		&i.BusinessType,
		&i.Description,
		&i.WebsiteUrl,
		&i.ApiKeyHash,
		&i.ApiKeyPrefix,
		&i.WebhookUrls,
		&i.WebhookSecret,
		&i.CustomStrategy,
		&i.EndUserYieldPortion,
		&i.IsActive,
		&i.IsSandbox,
		&i.PlatformFee,
		&i.PerformanceFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupportedCurrencies,
		&i.BankAccounts,
		&i.PrivyOrganizationID,
		&i.PrivyWalletAddress,
		&i.PrivyEmail,
		&i.PrivyWalletType,
	)
	return i, err
}

const getClientStats = `-- name: GetClientStats :one

SELECT
  c.id,
  c.product_id,
  c.company_name,
  c.is_active,
  c.created_at,
  cb.available AS balance_available,
  cb.reserved AS balance_reserved,
  COUNT(DISTINCT eu.id) AS total_end_users,
  COUNT(DISTINCT cv.id) AS total_vaults,
  COALESCE(SUM(cv.total_staked_balance), 0) AS total_aum,
  COALESCE(SUM(cv.cumulative_yield), 0) AS total_yield_earned,
  COUNT(DISTINCT dt.id) FILTER (WHERE dt.status = 'completed') AS total_deposits,
  COUNT(DISTINCT wt.id) FILTER (WHERE wt.status = 'completed') AS total_withdrawals
FROM client_organizations c
LEFT JOIN client_balances cb ON c.id = cb.client_id
LEFT JOIN end_users eu ON c.id = eu.client_id AND eu.is_active = true
LEFT JOIN client_vaults cv ON c.id = cv.client_id AND cv.is_active = true
LEFT JOIN deposit_transactions dt ON c.id = dt.client_id
LEFT JOIN withdrawal_transactions wt ON c.id = wt.client_id
WHERE c.id = $1
GROUP BY c.id, cb.available, cb.reserved
`

type GetClientStatsRow struct {
	ID               uuid.UUID          `db:"id"`
	ProductID        string             `db:"product_id"`
	CompanyName      string             `db:"company_name"`
	IsActive         bool               `db:"is_active"`
	CreatedAt        pgtype.Timestamptz `db:"created_at"`
	BalanceAvailable pgtype.Numeric     `db:"balance_available"`
	BalanceReserved  pgtype.Numeric     `db:"balance_reserved"`
	TotalEndUsers    int64              `db:"total_end_users"`
	TotalVaults      int64              `db:"total_vaults"`
	TotalAum         interface{}        `db:"total_aum"`
	TotalYieldEarned interface{}        `db:"total_yield_earned"`
	TotalDeposits    int64              `db:"total_deposits"`
	TotalWithdrawals int64              `db:"total_withdrawals"`
}

// ============================================
// CLIENT ANALYTICS
// ============================================
// Complete client statistics
func (q *Queries) GetClientStats(ctx context.Context, id uuid.UUID) (GetClientStatsRow, error) {
	row := q.db.QueryRow(ctx, getClientStats, id)
	var i GetClientStatsRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.CompanyName,
		&i.IsActive,
		&i.CreatedAt,
		&i.BalanceAvailable,
		&i.BalanceReserved,
		&i.TotalEndUsers,
		&i.TotalVaults,
		&i.TotalAum,
		&i.TotalYieldEarned,
		&i.TotalDeposits,
		&i.TotalWithdrawals,
	)
	return i, err
}

const getClientsByPrivyOrgID = `-- name: GetClientsByPrivyOrgID :many
SELECT
  co.id, co.privy_account_id, co.product_id, co.company_name, co.business_type, co.description, co.website_url, co.api_key_hash, co.api_key_prefix, co.webhook_urls, co.webhook_secret, co.custom_strategy, co.end_user_yield_portion, co.is_active, co.is_sandbox, co.platform_fee, co.performance_fee, co.created_at, co.updated_at, co.supported_currencies, co.bank_accounts,
  pa.privy_organization_id,
  pa.privy_wallet_address,
  pa.privy_email,
  pa.wallet_type AS privy_wallet_type
FROM client_organizations co
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE pa.privy_organization_id = $1
`

type GetClientsByPrivyOrgIDRow struct {
	ID                  uuid.UUID          `db:"id"`
	PrivyAccountID      uuid.UUID          `db:"privy_account_id"`
	ProductID           string             `db:"product_id"`
	CompanyName         string             `db:"company_name"`
	BusinessType        string             `db:"business_type"`
	Description         *string            `db:"description"`
	WebsiteUrl          *string            `db:"website_url"`
	ApiKeyHash          *string            `db:"api_key_hash"`
	ApiKeyPrefix        *string            `db:"api_key_prefix"`
	WebhookUrls         []string           `db:"webhook_urls"`
	WebhookSecret       *string            `db:"webhook_secret"`
	CustomStrategy      []byte             `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric     `db:"end_user_yield_portion"`
	IsActive            bool               `db:"is_active"`
	IsSandbox           bool               `db:"is_sandbox"`
	PlatformFee         pgtype.Numeric     `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric     `db:"performance_fee"`
	CreatedAt           pgtype.Timestamptz `db:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at"`
	SupportedCurrencies []string           `db:"supported_currencies"`
	BankAccounts        []byte             `db:"bank_accounts"`
	PrivyOrganizationID string             `db:"privy_organization_id"`
	PrivyWalletAddress  string             `db:"privy_wallet_address"`
	PrivyEmail          *string            `db:"privy_email"`
	PrivyWalletType     string             `db:"privy_wallet_type"`
}

func (q *Queries) GetClientsByPrivyOrgID(ctx context.Context, privyOrganizationID string) ([]GetClientsByPrivyOrgIDRow, error) {
	rows, err := q.db.Query(ctx, getClientsByPrivyOrgID, privyOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsByPrivyOrgIDRow
	for rows.Next() {
		var i GetClientsByPrivyOrgIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PrivyAccountID,
			&i.ProductID,
			&i.CompanyName,
			&i.BusinessType,
			&i.Description,
			&i.WebsiteUrl,
			&i.ApiKeyHash,
			&i.ApiKeyPrefix,
			&i.WebhookUrls,
			&i.WebhookSecret,
			&i.CustomStrategy,
			&i.EndUserYieldPortion,
			&i.IsActive,
			&i.IsSandbox,
			&i.PlatformFee,
			&i.PerformanceFee,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupportedCurrencies,
			&i.BankAccounts,
			&i.PrivyOrganizationID,
			&i.PrivyWalletAddress,
			&i.PrivyEmail,
			&i.PrivyWalletType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveClients = `-- name: ListActiveClients :many
SELECT
  co.id, co.privy_account_id, co.product_id, co.company_name, co.business_type, co.description, co.website_url, co.api_key_hash, co.api_key_prefix, co.webhook_urls, co.webhook_secret, co.custom_strategy, co.end_user_yield_portion, co.is_active, co.is_sandbox, co.platform_fee, co.performance_fee, co.created_at, co.updated_at, co.supported_currencies, co.bank_accounts,
  pa.privy_organization_id,
  pa.privy_wallet_address,
  pa.privy_email,
  pa.wallet_type AS privy_wallet_type
FROM client_organizations co
JOIN privy_accounts pa ON co.privy_account_id = pa.id
WHERE co.is_active = true
ORDER BY co.created_at DESC
`

type ListActiveClientsRow struct {
	ID                  uuid.UUID          `db:"id"`
	PrivyAccountID      uuid.UUID          `db:"privy_account_id"`
	ProductID           string             `db:"product_id"`
	CompanyName         string             `db:"company_name"`
	BusinessType        string             `db:"business_type"`
	Description         *string            `db:"description"`
	WebsiteUrl          *string            `db:"website_url"`
	ApiKeyHash          *string            `db:"api_key_hash"`
	ApiKeyPrefix        *string            `db:"api_key_prefix"`
	WebhookUrls         []string           `db:"webhook_urls"`
	WebhookSecret       *string            `db:"webhook_secret"`
	CustomStrategy      []byte             `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric     `db:"end_user_yield_portion"`
	IsActive            bool               `db:"is_active"`
	IsSandbox           bool               `db:"is_sandbox"`
	PlatformFee         pgtype.Numeric     `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric     `db:"performance_fee"`
	CreatedAt           pgtype.Timestamptz `db:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at"`
	SupportedCurrencies []string           `db:"supported_currencies"`
	BankAccounts        []byte             `db:"bank_accounts"`
	PrivyOrganizationID string             `db:"privy_organization_id"`
	PrivyWalletAddress  string             `db:"privy_wallet_address"`
	PrivyEmail          *string            `db:"privy_email"`
	PrivyWalletType     string             `db:"privy_wallet_type"`
}

func (q *Queries) ListActiveClients(ctx context.Context) ([]ListActiveClientsRow, error) {
	rows, err := q.db.Query(ctx, listActiveClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveClientsRow
	for rows.Next() {
		var i ListActiveClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.PrivyAccountID,
			&i.ProductID,
			&i.CompanyName,
			&i.BusinessType,
			&i.Description,
			&i.WebsiteUrl,
			&i.ApiKeyHash,
			&i.ApiKeyPrefix,
			&i.WebhookUrls,
			&i.WebhookSecret,
			&i.CustomStrategy,
			&i.EndUserYieldPortion,
			&i.IsActive,
			&i.IsSandbox,
			&i.PlatformFee,
			&i.PerformanceFee,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupportedCurrencies,
			&i.BankAccounts,
			&i.PrivyOrganizationID,
			&i.PrivyWalletAddress,
			&i.PrivyEmail,
			&i.PrivyWalletType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClients = `-- name: ListClients :many
SELECT
  co.id, co.privy_account_id, co.product_id, co.company_name, co.business_type, co.description, co.website_url, co.api_key_hash, co.api_key_prefix, co.webhook_urls, co.webhook_secret, co.custom_strategy, co.end_user_yield_portion, co.is_active, co.is_sandbox, co.platform_fee, co.performance_fee, co.created_at, co.updated_at, co.supported_currencies, co.bank_accounts,
  pa.privy_organization_id,
  pa.privy_wallet_address,
  pa.privy_email,
  pa.wallet_type AS privy_wallet_type
FROM client_organizations co
JOIN privy_accounts pa ON co.privy_account_id = pa.id
ORDER BY co.created_at DESC
LIMIT $1 OFFSET $2
`

type ListClientsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListClientsRow struct {
	ID                  uuid.UUID          `db:"id"`
	PrivyAccountID      uuid.UUID          `db:"privy_account_id"`
	ProductID           string             `db:"product_id"`
	CompanyName         string             `db:"company_name"`
	BusinessType        string             `db:"business_type"`
	Description         *string            `db:"description"`
	WebsiteUrl          *string            `db:"website_url"`
	ApiKeyHash          *string            `db:"api_key_hash"`
	ApiKeyPrefix        *string            `db:"api_key_prefix"`
	WebhookUrls         []string           `db:"webhook_urls"`
	WebhookSecret       *string            `db:"webhook_secret"`
	CustomStrategy      []byte             `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric     `db:"end_user_yield_portion"`
	IsActive            bool               `db:"is_active"`
	IsSandbox           bool               `db:"is_sandbox"`
	PlatformFee         pgtype.Numeric     `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric     `db:"performance_fee"`
	CreatedAt           pgtype.Timestamptz `db:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at"`
	SupportedCurrencies []string           `db:"supported_currencies"`
	BankAccounts        []byte             `db:"bank_accounts"`
	PrivyOrganizationID string             `db:"privy_organization_id"`
	PrivyWalletAddress  string             `db:"privy_wallet_address"`
	PrivyEmail          *string            `db:"privy_email"`
	PrivyWalletType     string             `db:"privy_wallet_type"`
}

func (q *Queries) ListClients(ctx context.Context, arg ListClientsParams) ([]ListClientsRow, error) {
	rows, err := q.db.Query(ctx, listClients, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientsRow
	for rows.Next() {
		var i ListClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.PrivyAccountID,
			&i.ProductID,
			&i.CompanyName,
			&i.BusinessType,
			&i.Description,
			&i.WebsiteUrl,
			&i.ApiKeyHash,
			&i.ApiKeyPrefix,
			&i.WebhookUrls,
			&i.WebhookSecret,
			&i.CustomStrategy,
			&i.EndUserYieldPortion,
			&i.IsActive,
			&i.IsSandbox,
			&i.PlatformFee,
			&i.PerformanceFee,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupportedCurrencies,
			&i.BankAccounts,
			&i.PrivyOrganizationID,
			&i.PrivyWalletAddress,
			&i.PrivyEmail,
			&i.PrivyWalletType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseReservedBalance = `-- name: ReleaseReservedBalance :exec

UPDATE client_balances
SET reserved = reserved - $2,
    available = available + $2,
    updated_at = now()
WHERE client_id = $1
  AND reserved >= $2
`

type ReleaseReservedBalanceParams struct {
	ClientID uuid.UUID      `db:"client_id"`
	Reserved pgtype.Numeric `db:"reserved"`
}

// Ensure sufficient balance
// Move from reserved back to available (e.g., transaction cancelled)
func (q *Queries) ReleaseReservedBalance(ctx context.Context, arg ReleaseReservedBalanceParams) error {
	_, err := q.db.Exec(ctx, releaseReservedBalance, arg.ClientID, arg.Reserved)
	return err
}

const reserveBalance = `-- name: ReserveBalance :exec
UPDATE client_balances
SET available = available - $2,
    reserved = reserved + $2,
    updated_at = now()
WHERE client_id = $1
  AND available >= $2
`

type ReserveBalanceParams struct {
	ClientID  uuid.UUID      `db:"client_id"`
	Available pgtype.Numeric `db:"available"`
}

// Move from available to reserved
func (q *Queries) ReserveBalance(ctx context.Context, arg ReserveBalanceParams) error {
	_, err := q.db.Exec(ctx, reserveBalance, arg.ClientID, arg.Available)
	return err
}

const updateClient = `-- name: UpdateClient :one
UPDATE client_organizations
SET company_name = COALESCE($2, company_name),
    business_type = COALESCE($3, business_type),
    description = COALESCE($4, description),
    website_url = COALESCE($5, website_url),
    webhook_urls = COALESCE($6, webhook_urls),
    webhook_secret = COALESCE($7, webhook_secret),
    custom_strategy = COALESCE($8, custom_strategy),
    end_user_yield_portion = COALESCE($9, end_user_yield_portion),
    platform_fee = COALESCE($10, platform_fee),
    performance_fee = COALESCE($11, performance_fee),
    updated_at = now()
WHERE id = $1
RETURNING id, privy_account_id, product_id, company_name, business_type, description, website_url, api_key_hash, api_key_prefix, webhook_urls, webhook_secret, custom_strategy, end_user_yield_portion, is_active, is_sandbox, platform_fee, performance_fee, created_at, updated_at, supported_currencies, bank_accounts
`

type UpdateClientParams struct {
	ID                  uuid.UUID      `db:"id"`
	CompanyName         *string        `db:"company_name"`
	BusinessType        *string        `db:"business_type"`
	Description         *string        `db:"description"`
	WebsiteUrl          *string        `db:"website_url"`
	WebhookUrls         []string       `db:"webhook_urls"`
	WebhookSecret       *string        `db:"webhook_secret"`
	CustomStrategy      []byte         `db:"custom_strategy"`
	EndUserYieldPortion pgtype.Numeric `db:"end_user_yield_portion"`
	PlatformFee         pgtype.Numeric `db:"platform_fee"`
	PerformanceFee      pgtype.Numeric `db:"performance_fee"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (ClientOrganization, error) {
	row := q.db.QueryRow(ctx, updateClient,
		arg.ID,
		arg.CompanyName,
		arg.BusinessType,
		arg.Description,
		arg.WebsiteUrl,
		arg.WebhookUrls,
		arg.WebhookSecret,
		arg.CustomStrategy,
		arg.EndUserYieldPortion,
		arg.PlatformFee,
		arg.PerformanceFee,
	)
	var i ClientOrganization
	err := row.Scan(
		&i.ID,
		&i.PrivyAccountID,
		&i.ProductID,
		&i.CompanyName,
		&i.BusinessType,
		&i.Description,
		&i.WebsiteUrl,
		&i.ApiKeyHash,
		&i.ApiKeyPrefix,
		&i.WebhookUrls,
		&i.WebhookSecret,
		&i.CustomStrategy,
		&i.EndUserYieldPortion,
		&i.IsActive,
		&i.IsSandbox,
		&i.PlatformFee,
		&i.PerformanceFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupportedCurrencies,
		&i.BankAccounts,
	)
	return i, err
}

const updateClientAPIKey = `-- name: UpdateClientAPIKey :exec
UPDATE client_organizations
SET api_key_hash = $2,
    api_key_prefix = $3,
    updated_at = now()
WHERE id = $1
`

type UpdateClientAPIKeyParams struct {
	ID           uuid.UUID `db:"id"`
	ApiKeyHash   *string   `db:"api_key_hash"`
	ApiKeyPrefix *string   `db:"api_key_prefix"`
}

func (q *Queries) UpdateClientAPIKey(ctx context.Context, arg UpdateClientAPIKeyParams) error {
	_, err := q.db.Exec(ctx, updateClientAPIKey, arg.ID, arg.ApiKeyHash, arg.ApiKeyPrefix)
	return err
}
