# App & Package-Specific Implementation Guides

**Purpose:** Detailed guides for specific apps and packages (supplements core documentation)

---

## ðŸ“± apps/b2b-api

### VaultId Handling in Deposits/Withdrawals

VaultId format: `{chain}-{tokenAddress}` (e.g., `base-0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`)

**In API contracts (required in request body):**
```typescript
// Deposit
createDeposit: {
  body: z.object({
    clientId: z.string(),
    userId: z.string(),
    vaultId: z.string(),      // â† Client specifies vault
    amount: z.string(),
  }),
}

// Withdrawal
createWithdrawal: {
  body: z.object({
    clientId: z.string(),
    userId: z.string(),
    vaultId: z.string(),      // â† Client specifies vault
    amount: z.string(),
  }),
}
```

**In database (for reference):**
- `deposit_transactions` stores: `client_id`, `user_id`, `currency` (derive vaultId from these)
- `withdrawal_transactions` stores: `client_id`, `user_id` (derive vaultId from these)

---

## ðŸ“¦ packages/core

### Privy Architecture & Implementation

**Server-Side MPC Wallets:**
- One wallet per client (corporate wallet)
- Controlled by Privy SDK (non-custodial for Quirk)
- Used for DeFi transactions and on/off ramps

**Key Concepts:**
- `userId` â‰  `privyUserId` (never confuse them!)
- `userId` format: `email:user@x.com` or `wallet:0x123...`
- Auto-generated by system for consistency

**Wallet Creation Flow:**
1. Client registers on Quirk Dashboard
2. Privy creates Server-Side MPC wallet for client
3. Store `privyAccountId` + `walletAddress` in database
4. Use wallet for batch DeFi operations

### Index-Based Accounting System

**Core Formula:**
```typescript
userValue = (amount Ã— currentIndex) / entryIndex
```

**Example:**
- User deposits: $100 at index 1.0 â†’ `entryIndex = 1.0`
- Vault grows to: index 1.05 (5% yield)
- User value: (100 Ã— 1.05) / 1.0 = $105

**Index Update After Yield:**
```typescript
newIndex = currentIndex Ã— (1 + yieldEarned / totalAUM)

// Safety check: prevent manipulation
if (newIndex > currentIndex Ã— 2) {
  throw new Error('Index growth exceeds safety limit')
}
```

**DCA (Dollar Cost Averaging) Support:**
```typescript
// When user deposits multiple times:
// Weighted entry index = sum(amount Ã— entryIndex) / sum(amount)

position1 = { amount: 100, entryIndex: 1.0 }  // $100 at 1.0
position2 = { amount: 50, entryIndex: 1.05 }  // $50 at 1.05

weightedIndex = ((100 Ã— 1.0) + (50 Ã— 1.05)) / (100 + 50)
              = (100 + 52.5) / 150
              = 1.0167
```

---

## ðŸŒ¾ packages/yield-engine

### DeFi Protocol Integration

**Supported Protocols:**

#### AAVE V3
- **APY Range:** 3-4% (USDC on Ethereum/Base)
- **Risk:** Low
- **TVL:** $10B+
- **Use:** Conservative/Moderate strategies
- **Min Liquidity:** High (always available)

#### Compound V3
- **APY Range:** 3-4% (USDC)
- **Risk:** Low
- **TVL:** $3B+
- **Use:** Conservative/Moderate strategies
- **Min Liquidity:** High

#### Morpho
- **APY Range:** 4-5% (optimized yields)
- **Risk:** Medium
- **TVL:** $500M+
- **Use:** Moderate/Morpho strategies
- **Min Liquidity:** Medium

**Adapter Pattern for Protocol Integration:**

```typescript
interface IProtocolAdapter {
  getSupplyAPY(token: string, chainId: number): Promise<string>
  getBorrowAPY(token: string, chainId: number): Promise<string>
  getMetrics(token: string, chainId: number): Promise<ProtocolMetrics>
  getTVL(chainId: number): Promise<string>
}

// Each protocol (AAVE, Compound, Morpho) implements this interface
```

**Caching Strategy:**
- Level 1: In-memory cache (fast, TTL: 30s)
- Level 2: Redis cache (medium, TTL: 5min)
- Level 3: On-chain data (slow, source of truth)

**Error Handling:**
- Graceful degradation: If one protocol fails, others continue
- Retry with exponential backoff: 3 attempts max
- Fallback to safest protocol if all fail

---

## ðŸŽ¨ apps/whitelabel-web

### Dashboard Architecture

**Page Structure:**
- `/` â†’ Login (Privy auth)
- `/dashboard` â†’ Main dashboard (after login)
- `/dashboard/analytics` â†’ Revenue & user growth metrics
- `/dashboard/settings` â†’ Configuration (strategies, bank accounts, currencies)
- `/demo/...` â†’ Demo app flows

**Authentication:**
- Privy session for dashboard access
- Extract `privyOrgId` from session headers
- Load client data from `privyOrgId`

**State Management:**
- React Query: Server state (API data)
- Zustand: UI state (modals, forms)
- TanStack Router: Navigation

**Key Components:**
- `EnvironmentSelector` â†’ Switch between clients (for multi-product orgs)
- `DashboardPage` â†’ Main dashboard layout
- `Analytics tabs` â†’ Revenue, users, transactions, balances

---

## ðŸª™ apps/mock-erc20

### MockUSDC Setup (Testing)

**Contract Address (Sepolia):**
```
0x1d02848c34ed2155613dd5cd26ce20a601b9a489
```

**Contract Details:**
- Symbol: USDQ (MockUSDC)
- Decimals: 6
- Mintable: Yes (for testing only)

**Minting Test Tokens:**

```bash
# Using make command
make mint ADDRESS=0x... AMOUNT=1000

# Using hardhat directly
npx hardhat run scripts/mint.ts --network sepolia
```

**Programmatic Minting:**

```typescript
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'

const MOCK_USDC_ADDRESS = '0x1d02848c34ed2155613dd5cd26ce20a601b9a489'

async function mintMockUSDC(toAddress: string, amount: string) {
  const client = createWalletClient({
    account: privateKeyToAccount('0x...'),
    chain: sepolia,
    transport: http()
  })

  return await client.writeContract({
    address: MOCK_USDC_ADDRESS,
    abi: MockUSDC_ABI,
    functionName: 'mint',
    args: [toAddress, BigInt(amount) * BigInt(10 ** 6)]
  })
}
```

---

## ðŸ”‘ Authentication Patterns

### API Key Authentication (SDK Integration)

**Generation:**
- Client registers â†’ auto-generated API key (format: `pk_live_xxxxx`)
- Bcrypt hashed before storing in database
- Shown only once during registration

**Validation:**
```typescript
// Middleware
export const apiKeyAuth = (clientUsecase: ClientUsecase) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const apiKey = req.headers['x-api-key'] as string

    if (!apiKey || !apiKey.startsWith('pk_live_')) {
      return res.status(401).json({ error: 'Invalid API key format' })
    }

    const client = await clientUsecase.validateApiKey(apiKey)
    if (!client) {
      return res.status(401).json({ error: 'Invalid API key' })
    }

    req.client = client
    next()
  }
}
```

### Privy Session Authentication (Dashboard)

**Flow:**
1. User logs into dashboard
2. Privy provides session token
3. Frontend sends header: `X-Privy-Org-ID: {privyOrgId}`
4. Backend validates against Privy
5. Load all client products for that org

```typescript
export const privyAuth = (privyUsecase: PrivyUsecase) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const privyOrgId = req.headers['x-privy-org-id'] as string

    if (!privyOrgId) {
      return res.status(401).json({ error: 'Missing Privy org ID' })
    }

    const account = await privyUsecase.getByPrivyOrgId(privyOrgId)
    if (!account) {
      return res.status(401).json({ error: 'Invalid Privy account' })
    }

    req.privySession = {
      organizationId: privyOrgId,
      products: await clientUsecase.getClientsByPrivyOrgId(privyOrgId)
    }
    next()
  }
}
```

---

## ðŸ”— Related Documentation

- **Core Architecture:** See `docs/core/ARCHITECTURE.md`
- **Core Implementation:** See `docs/core/IMPLEMENTATION.md`
- **Quick Reference:** See `docs/core/QUICK_REFERENCE.md`
- **API Contracts:** See `packages/b2b-api-core/contracts/`
- **Privy Docs:** https://docs.privy.io/
- **AAVE Docs:** https://docs.aave.com/
- **Compound Docs:** https://compound.finance/docs/
- **Morpho Docs:** https://docs.morpho.org/

---

**Last Updated:** 2025-12-11
**Version:** 1.0
