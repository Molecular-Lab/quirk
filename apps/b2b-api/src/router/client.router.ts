/**
 * B2B Client Router - ts-rest implementation
 * Maps HTTP requests to service layer
 */

import type { initServer } from "@ts-rest/express";
import { b2bContract } from "@proxify/b2b-api-core";
import type { ClientService } from "../service/client.service";
import { logger } from "../logger";
import { randomUUID } from "crypto";

export const createClientRouter = (
	s: ReturnType<typeof initServer>,
	clientService: ClientService
): any => {
	return s.router(b2bContract.client, {
		// GET /clients/:id
		getById: async ({ params }: { params: { id: string } }) => {
			try {
				const client = await clientService.getClientByProductId(params.id);

				if (!client) {
					return {
						status: 404 as const,
						body: {
							success: false,
							error: "Client not found",
						},
					};
				}

				return {
					status: 200 as const,
					body: {
						id: client.id,
						productId: client.productId,
						companyName: client.companyName,
						businessType: client.businessType,
						description: client.description || null,
						websiteUrl: client.websiteUrl || null,
						walletType: client.walletType,
						privyOrganizationId: client.privyOrganizationId,
						isActive: client.isActive,
						isSandbox: client.isSandbox || false,
						createdAt: client.createdAt.toISOString(),
						updatedAt: client.updatedAt.toISOString(),
					},
				};
			} catch (error: any) {
				logger.error("Error getting client by ID", { error: error.message, params });
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to get client",
					},
				};
			}
		},

		// GET /clients/product/:productId
		getByProductId: async ({ params }: { params: { productId: string } }) => {
			try {
				const client = await clientService.getClientByProductId(params.productId);

				if (!client) {
					return {
						status: 404 as const,
						body: {
							success: false,
							error: "Client not found",
						},
					};
				}

				return {
					status: 200 as const,
					body: {
						id: client.id,
						productId: client.productId,
						companyName: client.companyName,
						businessType: client.businessType,
						description: client.description || null,
						websiteUrl: client.websiteUrl || null,
						walletType: client.walletType,
						privyOrganizationId: client.privyOrganizationId,
						isActive: client.isActive,
						isSandbox: client.isSandbox || false,
						createdAt: client.createdAt.toISOString(),
						updatedAt: client.updatedAt.toISOString(),
					},
				};
			} catch (error: any) {
				logger.error("Error getting client by product ID", { error: error.message, params });
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to get client",
					},
				};
			}
		},

		// GET /clients/:id/balance
		getBalance: async ({ params }: { params: { id: string } }) => {
			try {
				const balance = await clientService.getClientBalance(params.id);

				if (!balance) {
					return {
						status: 404 as const,
						body: {
							success: false,
							error: "Balance not found",
						},
					};
				}

				return {
					status: 200 as const,
					body: {
						available: balance.available,
						reserved: balance.reserved,
						currency: "USD",
					},
				};
			} catch (error: any) {
				logger.error("Error getting client balance", { error: error.message, params });
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to get balance",
					},
				};
			}
		},

		// POST /clients - Create new client
		create: async ({ body }: { body: any }) => {
			try {
				logger.info("Creating client", { body });
				console.log("creating client ", {body})
				
				// Generate Product ID using UUID (standard and secure)
				const productId = `prod_${randomUUID()}`;
				
				// Note: API key and webhook secret are NOT generated here
				// They will be generated later when client requests integration credentials
				// via a separate endpoint (e.g., POST /clients/:id/generate-api-key)
				
				// Map API DTO to internal DTO
				const request = {
					// Generated by backend
					productId,
					apiKeyHash: null, // Will be generated when client requests API key
					apiKeyPrefix: "sk_live",
					
					// From frontend request
					companyName: body.companyName,
					businessType: body.businessType,
					description: body.description || null,
					websiteUrl: body.websiteUrl || null,
					
					// Map API walletType to database values
					// API: "MANAGED" | "USER_OWNED" â†’ DB: "custodial" | "non-custodial"
					walletType: body.walletType === "MANAGED" ? "custodial" : "non-custodial",
					// Database expects 'proxify' or 'client', not 'PRIVY' or 'USER'
					walletManagedBy: body.walletType === "MANAGED" ? "proxify" : "client",
					
					// Privy integration
					privyOrganizationId: body.privyOrganizationId,
					privyWalletAddress: body.privyWalletAddress || `privy_wallet_${Date.now()}`,
					
					// Optional fields
					webhookUrls: body.webhookUrls || null,
					customStrategy: body.customStrategy || null,
					endUserYieldPortion: body.endUserYieldPortion || null,
					platformFee: body.platformFee || null,
					performanceFee: body.performanceFee || null,
					isActive: body.isActive ?? true,
					isSandbox: body.isSandbox ?? false,
				};

				logger.info("Mapped request", { request });

				const client = await clientService.createClient(request);

				logger.info("Client created successfully", { clientId: client.id, productId });

				// Return response WITHOUT credentials
				// API keys will be generated separately via POST /clients/:id/generate-api-key
				return {
					status: 201 as const,
					body: {
						id: client.id,
						productId: client.productId,
						companyName: client.companyName,
						businessType: client.businessType,
						description: client.description || null,
						websiteUrl: client.websiteUrl || null,
						walletType: client.walletType,
						privyOrganizationId: client.privyOrganizationId,
						isActive: client.isActive,
						isSandbox: client.isSandbox || false,
						createdAt: client.createdAt.toISOString(),
						updatedAt: client.updatedAt.toISOString(),
						// Note: No api_key or webhook_secret here
						// Client must call separate endpoint to generate integration credentials
					},
				};
			} catch (error: any) {
				logger.error("Error creating client", { 
					error: error.message, 
					stack: error.stack,
					body 
				});
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to create client",
					},
				};
			}
		},

		addFunds: async ({ params, body }: { params: { id: string }; body: any }) => {
			try {
				await clientService.addFunds({
					clientId: params.id,
					amount: body.amount,
					source: body.source,
					reference: body.reference,
				});

				return {
					status: 200 as const,
					body: {
						success: true,
						message: `Successfully added ${body.amount} to client balance`,
					},
				};
			} catch (error: any) {
				logger.error("Error adding funds", { error: error.message, params, body });
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to add funds",
					},
				};
			}
		},

		reserveFunds: async ({ params, body }: { params: { id: string }; body: any }) => {
			try {
				await clientService.reserveFunds({
					clientId: params.id,
					amount: body.amount,
					purpose: body.purpose,
					reference: body.reference,
				});

				return {
					status: 200 as const,
					body: {
						success: true,
						message: `Successfully reserved ${body.amount}`,
					},
				};
			} catch (error: any) {
				logger.error("Error reserving funds", { error: error.message, params, body });
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to reserve funds",
					},
				};
			}
		},

		releaseReservedFunds: async ({ params, body }: { params: { id: string }; body: any }) => {
			try {
				await clientService.releaseReservedFunds({
					clientId: params.id,
					amount: body.amount,
					purpose: body.purpose || "release",
					reference: body.reference,
				});

				return {
					status: 200 as const,
					body: {
						success: true,
						message: `Successfully released ${body.amount}`,
					},
				};
			} catch (error: any) {
				logger.error("Error releasing funds", { error: error.message, params, body });
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to release funds",
					},
				};
			}
		},

		deductReservedFunds: async ({ params, body }: { params: { id: string }; body: any }) => {
			try {
				await clientService.deductReservedFunds({
					clientId: params.id,
					amount: body.amount,
					purpose: body.purpose || "deduct",
					reference: body.reference,
				});

				return {
					status: 200 as const,
					body: {
						success: true,
						message: `Successfully deducted ${body.amount}`,
					},
				};
			} catch (error: any) {
				logger.error("Error deducting funds", { error: error.message, params, body });
				return {
					status: 400 as const,
					body: {
						success: false,
						error: error.message || "Failed to deduct funds",
					},
				};
			}
		},
	});
}
