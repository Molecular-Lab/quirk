import { create } from "zustand"
import { persist } from "zustand/middleware"

import { listOrganizationsByPrivyId } from "@/api/b2bClientHelpers"
import { generateDemoKeysForProduct } from "@/utils/demoApiKeys"

import { useClientContextStore } from "./clientContextStore"
import { useDemoStore } from "./demoStore"

// Organization type from userStore
export interface Organization {
	id: string
	productId: string
	companyName: string
	businessType: string
	description?: string
	websiteUrl?: string
	apiKeyPrefix?: string | null // ‚ö†Ô∏è Deprecated - use sandboxApiKeyPrefix/productionApiKeyPrefix
	sandboxApiKeyPrefix?: string | null // ‚úÖ Sandbox API key prefix (from database)
	productionApiKeyPrefix?: string | null // ‚úÖ Production API key prefix (from database)
	apiKey?: string | null // ‚úÖ Full API key (stored in Zustand)
	isActive: boolean
	isSandbox: boolean
	createdAt: string
	updatedAt: string
}

export type VisualizationType = "ecommerce" | "creators" | "gig-workers"

interface DemoProductState {
	// Product selection (loaded from userStore on demo entry)
	availableProducts: Organization[]
	selectedProductId: string | null
	selectedProduct: Organization | null

	// API Keys storage (per product)
	apiKeys: Record<string, string> // { productId: apiKey }

	// Visualization selection
	visualizationType: VisualizationType | null

	// Loading state
	isLoadingProducts: boolean
	loadError: string | null

	// Actions
	loadProducts: (products: Organization[], apiKeysMap?: Record<string, string>) => void
	loadProductsByPrivyId: (privyOrgId: string) => Promise<void>
	selectProduct: (productId: string, environment?: "sandbox" | "production") => void
	selectVisualization: (type: VisualizationType) => void
	setApiKey: (productId: string, apiKey: string) => void
	clearSelection: () => void
	reset: () => void

	// Computed getters
	getSelectedApiKey: () => string | null
	getApiKey: (productId: string) => string | null
	getApiKeyForEnvironment: (productId: string, environment: "sandbox" | "production") => string | null
	isProductReady: (productId: string, environment: "sandbox" | "production") => boolean
	hasSelectedProduct: () => boolean
	hasSelectedVisualization: () => boolean
	canStartDemo: () => boolean
}

const initialState = {
	availableProducts: [],
	selectedProductId: null,
	selectedProduct: null,
	apiKeys: {},
	visualizationType: null,
	isLoadingProducts: false,
	loadError: null,
}

export const useDemoProductStore = create<DemoProductState>()(
	persist(
		(set, get) => ({
			...initialState,

			// Load products from userStore (called on demo entry)
			loadProducts: (products: Organization[], apiKeysMap?: Record<string, string>) => {
				const currentApiKeys = get().apiKeys

				// Merge new API keys with existing ones (preserve existing keys)
				const apiKeys = {
					...currentApiKeys, // Keep existing API keys
					...(apiKeysMap || {}), // Add/override with new keys if provided
				}

				// Log per-product API key status for debugging
				products.forEach((org) => {
					const hasApiKey = !!(apiKeys[org.productId] || apiKeys[`${org.productId}_sandbox`])
					console.log(`[demoProductStore] üìã Processing product ${org.productId}:`, {
						companyName: org.companyName,
						productId: org.productId,
						hasApiKey,
						apiKeyFound: hasApiKey ? "YES" : "NO",
						apiKeySource: apiKeys[org.productId] ? "direct" : apiKeys[`${org.productId}_sandbox`] ? "sandbox" : "none",
					})
				})

				set({
					availableProducts: products,
					apiKeys,
					isLoadingProducts: false,
					loadError: null,
				})

				// If only one product, auto-select it
				if (products.length === 1) {
					get().selectProduct(products[0].productId)
				}

				// If selectedProductId exists but not in products, clear it
				const { selectedProductId, selectedProduct } = get()
				if (selectedProductId && !products.find((p) => p.productId === selectedProductId)) {
					console.log("[demoProductStore] Clearing stale product selection - product no longer exists")
					set({ selectedProductId: null, selectedProduct: null })
				} else if (selectedProduct) {
					// Also check if persisted selectedProduct.id (database UUID) is stale
					const freshProduct = products.find((p) => p.productId === selectedProductId)
					if (freshProduct && freshProduct.id !== selectedProduct.id) {
						// Database UUID changed - update selectedProduct with fresh data
						console.log("[demoProductStore] Updated stale product ID:", {
							oldId: selectedProduct.id,
							newId: freshProduct.id,
						})
						set({ selectedProduct: freshProduct })

						// Also update clientContextStore with fresh ID
						const { setClientContext } = useClientContextStore.getState()
						setClientContext({
							clientId: freshProduct.id,
							productId: freshProduct.productId,
							apiKey: get().apiKeys[freshProduct.productId] || "",
							companyName: freshProduct.companyName,
							businessType: freshProduct.businessType,
						})
					}
				}

			// FORCE RE-SELECT: If selectedProductId exists, re-select it to sync API key to clientContextStore
			// This handles page refresh case where selectedProductId is restored from localStorage
			// but API keys were just freshly generated and need to be synced
			if (selectedProductId && products.find((p) => p.productId === selectedProductId)) {
				// Get current environment (defaults to sandbox if not set)
				const currentEnv = useDemoStore.getState().selectedEnvironment || "sandbox"

				// Force re-select to sync API key to clientContextStore
				get().selectProduct(selectedProductId, currentEnv)
			}
			},

			// NOTE: loadApiKeysFromLocalStorage() method removed
			// API keys are now ALWAYS fetched fresh from API, never from localStorage
			// This prevents stale data issues and ensures latest prefixes are used

			// NEW: Load products by Privy ID (API call)
			loadProductsByPrivyId: async (privyOrgId: string) => {

				// ‚úÖ CLEAR OLD API KEYS - fresh load from API should regenerate all keys
				set({ apiKeys: {} })
				try {
					const response = await listOrganizationsByPrivyId(privyOrgId)

					// ‚úÖ Generate demo API keys for each organization
					const products = response.map((org) => {
						const { sandboxKey, productionKey } = generateDemoKeysForProduct(
							org.sandboxApiKeyPrefix,
							org.productionApiKeyPrefix,
						)

						// Auto-save generated keys to apiKeys map
						if (sandboxKey) {
							get().setApiKey(`${org.productId}_sandbox`, sandboxKey)
						}
						if (productionKey) {
							get().setApiKey(`${org.productId}_production`, productionKey)
						}

						return {
							id: org.id,
							productId: org.productId,
							companyName: org.companyName,
							businessType: org.businessType,
							description: org.description,
							websiteUrl: org.websiteUrl,
							apiKeyPrefix: org.apiKeyPrefix,
							sandboxApiKeyPrefix: org.sandboxApiKeyPrefix,
							productionApiKeyPrefix: org.productionApiKeyPrefix,
							isActive: org.isActive,
							isSandbox: org.isSandbox,
							createdAt: org.createdAt,
							updatedAt: org.updatedAt,
						}
					})

					set({ availableProducts: products, isLoadingProducts: false, loadError: null })

					// Validate persisted selection against fresh products
					const { selectedProductId, selectedProduct } = get()
					if (selectedProductId && !products.find((p) => p.productId === selectedProductId)) {
						console.log("[demoProductStore] Clearing stale product selection after API load")
						set({ selectedProductId: null, selectedProduct: null })
					} else if (selectedProduct) {
						const freshProduct = products.find((p) => p.productId === selectedProductId)
						if (freshProduct && freshProduct.id !== selectedProduct.id) {
							console.log("[demoProductStore] Updated stale product ID after API load:", {
								oldId: selectedProduct.id,
								newId: freshProduct.id,
							})
							set({ selectedProduct: freshProduct })

							// Update clientContextStore with fresh ID
							const { setClientContext } = useClientContextStore.getState()
							setClientContext({
								clientId: freshProduct.id,
								productId: freshProduct.productId,
								apiKey: get().apiKeys[freshProduct.productId] || "",
								companyName: freshProduct.companyName,
								businessType: freshProduct.businessType,
							})
						}
					}

					// If only one product, auto-select it
					if (products.length === 1) {
						// Use API keys already loaded in store (from Zustand persistence)
						get().selectProduct(products[0].productId)
					}
				} catch (error) {
					console.error("[demoProductStore] Failed to load products:", error)
					set({
						loadError: error instanceof Error ? error.message : "Failed to load products",
						isLoadingProducts: false,
					})
				}
			},

			// Select product by productId
			selectProduct: (productId: string, environment?: "sandbox" | "production") => {
				const { availableProducts, apiKeys, selectedProductId: previousProductId } = get()
				const product = availableProducts.find((p) => p.productId === productId)


				if (!product) {
					console.error(`[demoProductStore] ‚ùå Product not found: ${productId}`)
					return
				}

				// Use provided environment parameter, fallback to demoStore, default to "sandbox"
				const selectedEnv = environment || useDemoStore.getState().selectedEnvironment || "sandbox"

				// Get API key with environment awareness
				const envKey = apiKeys[`${productId}_${selectedEnv}`]
				const apiKey = envKey || apiKeys[productId]

					selectedProductId: productId,
					selectedProduct: product,
				})

				// Validate API key exists
				if (!apiKey) {
					console.error(
						`[demoProductStore] ‚ùå API key not found for product: ${productId}. Demo may not work correctly.`,
					)
					console.error("[demoProductStore] Please regenerate API key from Dashboard ‚Üí Products ‚Üí Configure Product")
					console.error("[demoProductStore] Current API keys in store:", Object.keys(apiKeys))
					console.error(
						"[demoProductStore] Available products:",
						availableProducts.map((p) => p.productId),
					)
					// Don't return - still set up the product context (will just fail API calls)
				}

				// Sync to clientContextStore for API calls
				const { setClientContext } = useClientContextStore.getState()
				setClientContext({
					clientId: product.id,
					productId: product.productId,
					apiKey: apiKey || "", // Empty string if no API key
					companyName: product.companyName,
					businessType: product.businessType,
				})

				// ‚úÖ FIX: Reset demoStore state when switching products
				// This ensures the old persona and end-user from a different product doesn't persist
				// Each product may have different platform (ecommerce/creators/gig-workers)
				const demoStore = useDemoStore.getState()
				demoStore.resetPersona() // Clears persona + end-user state
				demoStore.resetEndUser() // Extra safety: ensure end-user state is reset

				})
			},

			// Select visualization type
			selectVisualization: (type: VisualizationType) => {
				set({ visualizationType: type })
				console.log("[demoProductStore] Visualization selected:", type)
			},

			// Set API key for a specific product
			setApiKey: (productId: string, apiKey: string) => {
				const { apiKeys } = get()
				set({
					apiKeys: {
						...apiKeys,
						[productId]: apiKey,
					},
				})
				console.log("[demoProductStore] API key set for product:", productId)
			},

			// Clear current selection (reset to selector)
			clearSelection: () => {
				set({
					selectedProductId: null,
					selectedProduct: null,
					visualizationType: null,
					apiKeys: {}, // ‚úÖ Clear API keys when clearing selection
				})
			},

			// Full reset (clear everything including available products)
			reset: () => {
				set(initialState)
			},

			// Computed: Get API key for selected product (considers current environment)
			getSelectedApiKey: () => {
				const { selectedProductId, apiKeys } = get()
				if (!selectedProductId) return null

				// Get current environment from demoStore
				const environment = useDemoStore.getState().selectedEnvironment

				// Try environment-specific key first
				const envKey = apiKeys[`${selectedProductId}_${environment}`]
				if (envKey) return envKey

				return apiKeys[selectedProductId] || null
			},

			// Computed: Get API key for specific product (considers current environment)
			getApiKey: (productId: string) => {
				const { apiKeys } = get()
				// Get current environment from demoStore
				const environment = useDemoStore.getState().selectedEnvironment

				// Try environment-specific key first
				const envKey = apiKeys[`${productId}_${environment}`]
				if (envKey) return envKey

				// Fallback to non-environment key (backward compatibility)
				return apiKeys[productId] || null
			},

			// Computed: Get API key for specific product and environment
			getApiKeyForEnvironment: (productId: string, environment: "sandbox" | "production") => {
				const { apiKeys } = get()

				// Try environment-specific key first (e.g., "prod_xxx_sandbox")
				const envKey = apiKeys[`${productId}_${environment}`]
				if (envKey) return envKey

				// Fallback to base key (backward compatibility with Dashboard-saved keys)
				// Dashboard saves keys as just "productId" without environment suffix
				// We treat these as usable for both sandbox and production
				return apiKeys[productId] || null
			},

			// Computed: Check if product is ready for demo (has API key for environment)
			isProductReady: (productId: string, environment: "sandbox" | "production") => {
				// ‚úÖ FIX: Always check if demo key was generated and saved
				// Demo keys are auto-generated from prefixes when products are loaded
				const { apiKeys } = get()
				const apiKey = get().getApiKeyForEnvironment(productId, environment)

				console.log("[demoProductStore] isProductReady check:", {
					productId,
					environment,
					lookupKey: `${productId}_${environment}`,
					hasApiKey: !!apiKey,
					apiKeyPreview: apiKey?.substring(0, 16),
					allApiKeys: Object.keys(apiKeys),
					apiKeysMap: apiKeys,
				})

				return !!apiKey
			},

			// Computed: Check if product is selected
			hasSelectedProduct: () => {
				return get().selectedProductId !== null
			},

			// Computed: Check if visualization is selected
			hasSelectedVisualization: () => {
				return get().visualizationType !== null
			},

			// Computed: Check if ready to start demo
			canStartDemo: () => {
				return get().hasSelectedProduct() && get().hasSelectedVisualization()
			},
		}),
		{
			name: "proxify-demo-product-state", // localStorage key
			partialize: (state) => ({
				// Persist these fields for UX personalization
				selectedProductId: state.selectedProductId,
				selectedProduct: state.selectedProduct,
				visualizationType: state.visualizationType,
				// ‚úÖ apiKeys NOT persisted - always regenerate from API
				// Don't persist availableProducts - always reload from API
			}),
			onRehydrateStorage: () => {
				return (state, error) => {
					if (error) {
						console.error("[demoProductStore] ‚ùå Failed to load from localStorage:", error)
					} else if (state) {
					}
				}
			},
		},
	),
)
