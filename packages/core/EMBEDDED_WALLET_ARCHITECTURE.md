# Embedded Wallet Architecture

**Pattern:** Clean Architecture + Database Mapping Layer
**Purpose:** Support both Web3 native and Non-Web3 apps with unified embedded wallet infrastructure

---

## üéØ Problem Statement

We need to support **two different types of businesses**:

### 1. **Non-Web3 Apps** (No crypto knowledge)
- **Example:** Gaming platforms, social apps, fintech apps (like YouTube, Spotify)
- **User Identity:** App-specific `userId` only (e.g., "user123", "youtube-user-456")
- **Challenge:** Users have NO wallet address, NO crypto knowledge
- **What they need:**
  - Generate embedded wallet for userId
  - Get wallet by userId
  - Use wallet address for blockchain operations (deposits, withdrawals)

### 2. **Web3 Native Apps** (Crypto-first)
- **Example:** DeFi protocols, NFT marketplaces, DEX interfaces
- **User Identity:** Non-custodial wallet address (e.g., MetaMask address)
- **Challenge:** Users already have wallets, want to link to embedded wallet
- **What they need:**
  - Link existing wallet to embedded wallet
  - Get wallet by wallet address
  - Use embedded wallet for delegated operations

---

## üèóÔ∏è Architecture Design

### Key Insight: Database Mapping Layer

**Why we need it:**
- Privy SDK stores `customMetadata` but doesn't support efficient querying
- We need fast lookups by `productId + userId` OR `productId + walletAddress`
- ProductOwner uses their own `userId`, not Privy's DID

**Solution:**
```
ProductOwner userId ‚Üê‚Üí Database Mapping ‚Üê‚Üí Privy DID ‚Üê‚Üí Embedded Wallet Address
                              ‚Üï
                      Linked Wallet Address (optional, for web3 native)
```

---

## üìä Database Schema

```sql
CREATE TABLE user_embedded_wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Product identification
  product_id VARCHAR(255) NOT NULL,

  -- User identification (ProductOwner's app-specific user ID)
  user_id VARCHAR(255) NOT NULL,

  -- Privy identification
  privy_user_id VARCHAR(255) NOT NULL UNIQUE,

  -- Wallet addresses
  embedded_wallet_address VARCHAR(42) NOT NULL,   -- Generated by Privy
  linked_wallet_address VARCHAR(42),              -- Optional: User's existing wallet

  -- Blockchain info
  chain_type VARCHAR(50) NOT NULL,                -- "ethereum", "solana", etc.

  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  -- Constraints
  UNIQUE(product_id, user_id),                    -- One wallet per user per product
  UNIQUE(product_id, embedded_wallet_address),
  UNIQUE(product_id, linked_wallet_address) WHERE linked_wallet_address IS NOT NULL
);

-- Indexes for fast lookups
CREATE INDEX idx_product_user ON user_embedded_wallets(product_id, user_id);
CREATE INDEX idx_product_embedded_wallet ON user_embedded_wallets(product_id, embedded_wallet_address);
CREATE INDEX idx_product_linked_wallet ON user_embedded_wallets(product_id, linked_wallet_address)
  WHERE linked_wallet_address IS NOT NULL;
```

---

## üîÑ Request Flows

### Flow 1: Non-Web3 App - Create Wallet

**Use Case:** Gaming platform wants to create wallet for user "player123"

```typescript
// Request from ProductOwner
POST /api/v1/embedded-wallets/create
{
  "productId": "gaming-platform-a",
  "userId": "player123",
  "chainType": "ethereum"
}

// Flow:
1. EmbeddedWalletUsecase.createEmbeddedWallet()
2. Check database: Does (productId, userId) exist?
   - If YES: Return existing wallet (idempotent)
   - If NO: Continue to step 3
3. Call Privy SDK: privyUserRepository.createUser({
     wallets: [{ chainType: "ethereum" }],
     customMetadata: { productId, userId }
   })
4. Extract embedded wallet address from Privy response
5. Store mapping in database:
   - product_id: "gaming-platform-a"
   - user_id: "player123"
   - privy_user_id: "did:privy:xxxxx"
   - embedded_wallet_address: "0xABC...123"
   - linked_wallet_address: null
6. Return response

// Response
{
  "success": true,
  "data": {
    "userId": "player123",
    "walletAddress": "0xABC...123",      // ‚Üê They use this for blockchain ops
    "privyUserId": "did:privy:xxxxx",
    "chainType": "ethereum"
  }
}
```

**What ProductOwner gets:**
- ‚úÖ `userId`: Their own user ID (they already know this)
- ‚úÖ `walletAddress`: The embedded wallet address (NEW - they need this)
- ‚úÖ `privyUserId`: Privy's internal ID (optional, for advanced usage)

**What ProductOwner does with `walletAddress`:**
- Use it when calling deposit endpoint: `POST /deposit { userId, walletAddress, amount }`
- Use it when calling withdraw endpoint: `POST /withdraw { userId, walletAddress, amount }`
- Store it in their database alongside userId
- Display it to user (optional)

---

### Flow 2: Non-Web3 App - Get Wallet by UserId

**Use Case:** Gaming platform wants to get wallet for user "player123"

```typescript
// Request
GET /api/v1/embedded-wallets/user/{productId}/{userId}

// Flow:
1. EmbeddedWalletUsecase.getEmbeddedWalletByUserId({ productId, userId })
2. Query database: SELECT * WHERE product_id = ? AND user_id = ?
3. Return wallet mapping (NO Privy SDK call needed - fast!)

// Response
{
  "success": true,
  "data": {
    "userId": "player123",
    "walletAddress": "0xABC...123",
    "privyUserId": "did:privy:xxxxx",
    "chainType": "ethereum",
    "createdAt": "2024-11-12T..."
  }
}
```

---

### Flow 3: Web3 Native App - Create Wallet with Linked Address

**Use Case:** DeFi protocol where user connects MetaMask (0xDEF...456)

```typescript
// Request from ProductOwner
POST /api/v1/embedded-wallets/create
{
  "productId": "defi-protocol-b",
  "userId": "defi-user-789",
  "chainType": "ethereum",
  "linkedWalletAddress": "0xDEF...456"  // ‚Üê User's MetaMask address
}

// Flow:
1. EmbeddedWalletUsecase.createEmbeddedWallet()
2. Check database: Does (productId, userId) exist?
   - If YES: Return existing wallet
   - If NO: Continue
3. Call Privy SDK: privyUserRepository.createUser({
     linkedAccounts: [
       { type: "wallet", address: "0xDEF...456" }  // ‚Üê Link their wallet
     ],
     wallets: [{ chainType: "ethereum" }],
     customMetadata: { productId, userId, linkedWalletAddress: "0xDEF...456" }
   })
4. Extract embedded wallet address: "0xABC...789"
5. Store mapping in database:
   - product_id: "defi-protocol-b"
   - user_id: "defi-user-789"
   - privy_user_id: "did:privy:yyyyy"
   - embedded_wallet_address: "0xABC...789"
   - linked_wallet_address: "0xDEF...456"  // ‚Üê Their original wallet
6. Return response

// Response
{
  "success": true,
  "data": {
    "userId": "defi-user-789",
    "embeddedWalletAddress": "0xABC...789",    // ‚Üê Privy-controlled wallet
    "linkedWalletAddress": "0xDEF...456",      // ‚Üê User's MetaMask wallet
    "privyUserId": "did:privy:yyyyy",
    "chainType": "ethereum"
  }
}
```

---

### Flow 4: Web3 Native App - Get Wallet by Address

**Use Case:** User connects with MetaMask (0xDEF...456), app wants to find their profile

```typescript
// Request
GET /api/v1/embedded-wallets/address/{productId}/{walletAddress}

// Flow:
1. EmbeddedWalletUsecase.getEmbeddedWalletByAddress({ productId, walletAddress: "0xDEF...456" })
2. Query database:
   SELECT * WHERE product_id = ?
   AND (embedded_wallet_address = ? OR linked_wallet_address = ?)
3. Return wallet mapping

// Response
{
  "success": true,
  "data": {
    "userId": "defi-user-789",               // ‚Üê Now they know the userId
    "embeddedWalletAddress": "0xABC...789",
    "linkedWalletAddress": "0xDEF...456",
    "privyUserId": "did:privy:yyyyy",
    "chainType": "ethereum"
  }
}
```

---

## üé® API Design

### For Non-Web3 Apps (userId-based)

```typescript
// Create wallet
POST /api/v1/embedded-wallets/create
Body: {
  productId: string
  userId: string
  chainType: string
}
Response: { userId, walletAddress, privyUserId }

// Get wallet
GET /api/v1/embedded-wallets/user/:productId/:userId
Response: { userId, walletAddress, privyUserId, chainType }

// Use wallet for operations
POST /api/v1/wallets/:walletAddress/deposit
POST /api/v1/wallets/:walletAddress/withdraw
```

### For Web3 Native Apps (wallet-based)

```typescript
// Create wallet with linked address
POST /api/v1/embedded-wallets/create
Body: {
  productId: string
  userId: string
  chainType: string
  linkedWalletAddress: string  // ‚Üê User's existing wallet
}
Response: { userId, embeddedWalletAddress, linkedWalletAddress, privyUserId }

// Get wallet by address
GET /api/v1/embedded-wallets/address/:productId/:walletAddress
Response: { userId, embeddedWalletAddress, linkedWalletAddress, privyUserId }

// Link wallet later
PUT /api/v1/embedded-wallets/link
Body: {
  productId: string
  userId: string
  walletAddress: string
}
Response: { userId, embeddedWalletAddress, linkedWalletAddress }
```

---

## üìÅ Code Structure

```
@proxify/core/
‚îú‚îÄ‚îÄ entity/
‚îÇ   ‚îú‚îÄ‚îÄ privy-user.entity.ts              # Privy user schema (Zod)
‚îÇ   ‚îú‚îÄ‚îÄ privy-wallet.entity.ts            # Privy wallet schema (Zod)
‚îÇ   ‚îî‚îÄ‚îÄ user-embedded-wallet.entity.ts    # Database mapping schema (NEW)
‚îú‚îÄ‚îÄ datagateway/
‚îÇ   ‚îú‚îÄ‚îÄ privy-user.datagateway.ts         # Privy user operations interface
‚îÇ   ‚îú‚îÄ‚îÄ privy-wallet.datagateway.ts       # Privy wallet operations interface
‚îÇ   ‚îî‚îÄ‚îÄ user-embedded-wallet.datagateway.ts # Database operations interface (NEW)
‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îú‚îÄ‚îÄ privy/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.repository.ts            # Privy SDK implementation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wallet.repository.ts          # Privy SDK implementation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ privy.repository.ts           # Aggregator
‚îÇ   ‚îî‚îÄ‚îÄ database/
‚îÇ       ‚îî‚îÄ‚îÄ user-embedded-wallet.repository.ts # PostgreSQL implementation (TODO)
‚îî‚îÄ‚îÄ usecase/
    ‚îú‚îÄ‚îÄ privy.usecase.ts                  # Low-level Privy operations (DEPRECATED)
    ‚îî‚îÄ‚îÄ embedded-wallet.usecase.ts        # High-level embedded wallet operations (NEW)
```

---

## ‚úÖ Decision Summary

### ‚ùì Question: What to return to non-web3 businesses?

**‚úÖ Answer:** Return BOTH `userId` AND `walletAddress`

**Why?**
- `userId`: They need it for user identification (they provided it)
- `walletAddress`: They need it for blockchain operations (deposit, withdraw, transfer)

### ‚ùì Question: How to identify users?

**‚úÖ Answer:** ProductOwner ALWAYS provides `userId` (their own user ID)

**Two patterns:**
1. **Non-Web3:** `{ productId, userId }` ‚Üí Get wallet
2. **Web3 Native:** `{ productId, walletAddress }` ‚Üí Get userId + wallet

### ‚ùì Question: How to handle both user types?

**‚úÖ Answer:** Database mapping layer + unified API

**Key insight:**
- Store mapping in database for fast lookups
- Support both query patterns (by userId OR by walletAddress)
- Use optional `linkedWalletAddress` field for web3 native users

---

## üöÄ Implementation Checklist

- [x] Entity layer: `user-embedded-wallet.entity.ts`
- [x] Datagateway: `user-embedded-wallet.datagateway.ts`
- [x] Usecase: `embedded-wallet.usecase.ts`
- [ ] Repository: `user-embedded-wallet.repository.ts` (PostgreSQL)
- [ ] Database migration: Create `user_embedded_wallets` table
- [ ] API handlers: Express/Elysia endpoints
- [ ] Tests: Unit + integration tests
- [ ] Documentation: API documentation

---

**Last Updated:** 2025-11-12
**Status:** Design Complete, Implementation In Progress
**Pattern:** Clean Architecture + Database Mapping Layer
