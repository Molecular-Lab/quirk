# AAVE V3 Integration Research Document

**Last Updated**: November 19, 2024
**Status**: Implementation Ready

---

## Executive Summary

This document provides comprehensive guidance for integrating AAVE V3 into the Quirk yield optimization engine. It covers contract addresses, ABIs, key methods for fetching supply APY, user positions, and practical implementation examples using viem and TypeScript.

---

## 1. Package Dependencies

Already installed in `package.json`:

```json
{
  "@aave-dao/aave-v3-origin": "^3.5.0",
  "@aave/math-utils": "^1.29.7",
  "@bgd-labs/aave-address-book": "^4.36.0",
  "viem": "^2.38.3"
}
```

---

## 2. AAVE Address Book Usage

### Installation & Import

The `@bgd-labs/aave-address-book` package provides an up-to-date registry of all AAVE smart contract addresses.

```typescript
import {
  AaveV3Ethereum,
  AaveV3Polygon,
  AaveV3Base,
  AaveV3Arbitrum
} from '@bgd-labs/aave-address-book'

// Access Pool contract address
console.log(AaveV3Ethereum.POOL) // "0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2"
console.log(AaveV3Ethereum.POOL_ADDRESSES_PROVIDER)
console.log(AaveV3Ethereum.CHAIN_ID)
```

### Core Contract Addresses by Chain

#### Ethereum Mainnet (Chain ID: 1)
- **Pool**: `0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2`
- **Pool Addresses Provider**: `0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e`
- **Protocol Data Provider**: `0x7B4EB56E7CD4b454BA8ff71E4518426369a138a3`

#### Polygon (Chain ID: 137)
- **Pool**: `0x794a61358D6845594F94dc1DB02A252b5b4814aD`
- **Pool Addresses Provider**: `0xa97684ead0e402dc232d5a977953df7ecbab3cdb`
- **Protocol Data Provider**: `0x69FA688f1Dc47d4B5d8029D5a35FB7a548310654`

#### Arbitrum One (Chain ID: 42161)
- **Pool**: `0x794a61358D6845594F94dc1DB02A252b5b4814aD`
- **Protocol Data Provider**: `0x69fa688f1Dc47d4B5d8029d5a35FB7a548310654`

#### Base (Chain ID: 8453)
- **Pool**: `0x794a61358D6845594F94dc1DB02A252b5b4814aD`
- **Protocol Data Provider**: `0x69FA688f1Dc47d4B5d8029D5a35FB7a548310654`

**Note**: Most chains use the same Pool address (`0x794a61358D6845594F94dc1DB02A252b5b4814aD`), except Ethereum Mainnet.

### Token Addresses (USDC & USDT)

#### Ethereum Mainnet
- **USDC**: `0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48`
- **USDT**: `0xdAC17F958D2ee523a2206206994597C13D831ec7`

#### Polygon
- **USDC (Native)**: `0x3c499c542cef5e3811e1192ce70d8cc03d5c3359`
- **USDC.e (Bridged)**: `0x2791Bca1f2de4661ed88a30c99a7a9449aa84174`
- **USDT**: `0xc2132D05D31c914a87C6611C10748AEb04B58e8F`

#### Arbitrum One
- **USDC (Native)**: `0xaf88d065e77c8cc2239327c5edb3a432268e5831`
- **USDT**: `0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9`

#### Base
- **USDC (Native)**: `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`
- **USDbC (Bridged)**: `0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA`

**Important**: Prefer native USDC where available for Circle-issued tokens.

---

## 3. Pool Contract Interface

### Key Methods for Yield Optimization

#### 3.1 getReserveData(address asset)

**Purpose**: Returns the state and configuration of a reserve, including the supply APY (liquidityRate).

**Function Signature**:
```solidity
function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);
```

**Return Structure** (DataTypes.ReserveData):
```typescript
{
  configuration: uint256;
  liquidityIndex: uint128;              // Ray format (1e27)
  currentLiquidityRate: uint128;        // Ray format (1e27) - THIS IS THE SUPPLY APR
  variableBorrowIndex: uint128;
  currentVariableBorrowRate: uint128;
  currentStableBorrowRate: uint128;
  lastUpdateTimestamp: uint40;
  id: uint16;
  aTokenAddress: address;               // Address of the aToken contract
  stableDebtTokenAddress: address;
  variableDebtTokenAddress: address;
  interestRateStrategyAddress: address;
  accruedToTreasury: uint128;
  unbacked: uint128;
  isolationModeTotalDebt: uint128;
}
```

**Key Field**: `currentLiquidityRate` - This is the supply APR in Ray format (1e27). Must convert to APY using compound interest formula.

#### 3.2 Getting User's Deposited Amount

**Method: Using aToken balanceOf()**

The recommended way to get a user's deposited amount is to call `balanceOf()` on the aToken contract:

```typescript
// Get aToken address from getReserveData
const reserveData = await pool.getReserveData(assetAddress)
const aTokenAddress = reserveData.aTokenAddress

// Call balanceOf on the aToken contract
const balance = await aTokenContract.balanceOf(userAddress)
```

**Important**: The `balanceOf()` function returns the most up-to-date balance including:
- Principal balance (original deposit)
- Yield generated by the principal balance

The balance continuously increases as interest accrues, reflecting real-time compounded returns.

---

## 4. APY Calculation

### Understanding Rate Formats

**Ray Format**: All rates in AAVE are expressed in Ray units (1e27):
- `RAY = 10^27`
- `SECONDS_PER_YEAR = 31536000`

### Formula to Convert liquidityRate to Supply APY

The `currentLiquidityRate` from `getReserveData()` is the supply APR (not compounded).

**Step 1**: Convert Ray to decimal APR
```typescript
const depositAPR = liquidityRate / RAY
```

**Step 2**: Apply compound interest formula
```typescript
const depositAPY = Math.pow(1 + (depositAPR / SECONDS_PER_YEAR), SECONDS_PER_YEAR) - 1
```

**Complete formula**:
```typescript
depositAPY = ((1 + (liquidityRate / RAY) / SECONDS_PER_YEAR) ^ SECONDS_PER_YEAR) - 1
```

### Using @aave/math-utils

The `@aave/math-utils` package provides utility functions to handle this calculation:

```typescript
import { rayPow } from '@aave/math-utils'

const RAY = '1000000000000000000000000000' // 1e27
const SECONDS_PER_YEAR = 31536000

const supplyAPY = rayPow(
  valueToZDBigNumber(reserve.liquidityRate)
    .dividedBy(SECONDS_PER_YEAR)
    .plus(RAY),
  SECONDS_PER_YEAR
).minus(RAY)
```

### Recommendation

**Use @aave/math-utils** for:
1. Battle-tested calculations used by AAVE's official UI
2. Handles edge cases and precision issues
3. Includes additional formatting utilities
4. Already installed in package.json

---

## 5. Implementation Example with Viem

### Complete Example: Fetching Supply APY

```typescript
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
import { AaveV3Ethereum } from '@bgd-labs/aave-address-book'

// Pool ABI (minimal for getReserveData)
const poolABI = [
  {
    name: 'getReserveData',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'asset', type: 'address' }],
    outputs: [{
      name: '',
      type: 'tuple',
      components: [
        { name: 'configuration', type: 'uint256' },
        { name: 'liquidityIndex', type: 'uint128' },
        { name: 'currentLiquidityRate', type: 'uint128' },
        { name: 'variableBorrowIndex', type: 'uint128' },
        { name: 'currentVariableBorrowRate', type: 'uint128' },
        { name: 'currentStableBorrowRate', type: 'uint128' },
        { name: 'lastUpdateTimestamp', type: 'uint40' },
        { name: 'id', type: 'uint16' },
        { name: 'aTokenAddress', type: 'address' },
        { name: 'stableDebtTokenAddress', type: 'address' },
        { name: 'variableDebtTokenAddress', type: 'address' },
        { name: 'interestRateStrategyAddress', type: 'address' },
        { name: 'accruedToTreasury', type: 'uint128' },
        { name: 'unbacked', type: 'uint128' },
        { name: 'isolationModeTotalDebt', type: 'uint128' }
      ]
    }]
  }
] as const

// Create viem client
const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

// USDC address on Ethereum
const USDC_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

// Fetch reserve data
const reserveData = await client.readContract({
  address: AaveV3Ethereum.POOL as `0x${string}`,
  abi: poolABI,
  functionName: 'getReserveData',
  args: [USDC_ADDRESS as `0x${string}`]
})

// Extract liquidityRate (supply APR in Ray format)
const currentLiquidityRate = reserveData.currentLiquidityRate
const aTokenAddress = reserveData.aTokenAddress

// Convert to APY
const RAY = 1e27
const SECONDS_PER_YEAR = 31536000

const aprDecimal = Number(currentLiquidityRate) / RAY
const apyDecimal = Math.pow(1 + aprDecimal / SECONDS_PER_YEAR, SECONDS_PER_YEAR) - 1
const apyPercentage = apyDecimal * 100

console.log(`USDC Supply APY: ${apyPercentage.toFixed(2)}%`)
console.log(`aToken Address: ${aTokenAddress}`)
```

### Getting User Balance

```typescript
// ERC20 ABI (minimal for balanceOf)
const erc20ABI = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ name: '', type: 'uint256' }]
  }
] as const

// Get user's aToken balance (includes principal + accrued interest)
const userAddress = '0x...' // User's address
const balance = await client.readContract({
  address: aTokenAddress,
  abi: erc20ABI,
  functionName: 'balanceOf',
  args: [userAddress as `0x${string}`]
})

console.log(`User's deposited USDC (with interest): ${balance}`)
```

---

## 6. Key Takeaways & Recommendations

### Questions Answered

1. **What's the exact method to call to get current supply APY?**
   - Call `getReserveData(address asset)` on the Pool contract
   - Extract `currentLiquidityRate` from the returned struct
   - This is the supply APR (not yet compounded)

2. **How is the APY returned?**
   - Yes, in Ray format (1e27)
   - Must convert using compound interest formula

3. **How do we get user's deposited amount?**
   - Through aTokens: Call `balanceOf(userAddress)` on the aToken contract
   - Get aToken address from `getReserveData().aTokenAddress`

4. **What are the essential contract addresses we need?**
   - Pool contract (main entry point)
   - Token addresses (USDC, USDT) for each chain
   - All available via `@bgd-labs/aave-address-book`

5. **Do we need @aave/math-utils?**
   - Yes, recommended for reliable APY calculations
   - Already installed and battle-tested

### Implementation Strategy

1. **Use @bgd-labs/aave-address-book** for all contract addresses
2. **Use viem** for blockchain interactions
3. **Use @aave/math-utils** for APY calculations
4. **Cache results** to reduce RPC calls (5-minute TTL)
5. **Handle multiple chains** by parameterizing chain-specific addresses

### Next Steps

1. Create AAVE adapter class in `/src/protocols/aave/`
2. Implement methods:
   - `getSupplyAPY(token, chainId)`
   - `getUserPosition(token, userAddress, chainId)`
   - `getMetrics(token, chainId)`
3. Use the address configuration structure
4. Add tests for each chain
5. Integrate with caching and RPC utility layers

---

## 7. Additional Resources

- **AAVE V3 Docs**: https://aave.com/docs/developers/smart-contracts/pool
- **Address Book GitHub**: https://github.com/bgd-labs/aave-address-book
- **AAVE V3 Core GitHub**: https://github.com/aave/aave-v3-core
- **AAVE Math Utils**: https://github.com/aave/aave-utilities
- **Rates Guide**: https://docs.aave.com/developers/guides/rates-guide

---

**Implementation Date**: November 19, 2024
**Primary Tokens**: USDC, USDT
**Supported Chains**: Ethereum (1), Polygon (137), Base (8453), Arbitrum (42161)
